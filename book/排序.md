#### 十大排序

![](E:\books\算法与数据结构综合(C++)学习算法思想，修炼编程内功\sort.png)

https://zhuanlan.zhihu.com/developer1024

##### 堆排序

步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般**升序采用大顶堆，降序采用小顶堆**)。

步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。

**一.初始化建堆**https://blog.csdn.net/qq_34228570/article/details/80024306
　　初始化建堆只需要对二叉树的非叶子节点调用adjusthead()函数，由下至上，由右至左选取非叶子节点来调用adjusthead()函数。那么倒数第二层的最右边的非叶子节点就是最后一个非叶子结点。
　　假设高度为k，则从倒数第二层右边的节点开始，这一层的节点都要执行子节点比较然后交换（如果顺序是对的就不用交换）；倒数第三层呢，则会选择其子节点进行比较和交换，如果没交换就可以不用再执行下去了。如果交换了，那么又要选择一支子树进行比较和交换；高层也是这样逐渐递归。
　　那么总的时间计算为：s = 2^( i - 1 ) * ( k - i )；其中 i 表示第几层，2^( i - 1) 表示该层上有多少个元素，( k - i) 表示子树上要下调比较的次数。
　　S = 2^(k-2) * 1 + 2^(k-3)2…..+2(k-2)+2^(0)*(k-1) ===> 因为叶子层不用交换，所以i从 k-1 开始到 1；
　　S = 2^k -k -1；又因为k为完全二叉树的深度，而log(n) =k，把此式带入；
　　得到：S = n - log(n) -1，所以时间复杂度为：**O(n)**

**二.排序重建堆**
　　在取出堆顶点放到对应位置并把原堆的最后一个节点填充到堆顶点之后，需要对堆进行重建，只需要对堆的顶点调用adjustheap()函数。
　　每次重建意味着有一个节点出堆，所以需要将堆的容量减一。adjustheap()函数的时间复杂度k=log(n)，k为堆的层数。所以在每次重建时，随着堆的容量的减小，层数会下降，函数时间复杂度会变化。重建堆一共需要n-1次循环，每次循环的比较次数为log(i)，则相加为：log2+log3+…+log(n-1)+log(n)≈log(n!)。可以证明log(n!)和nlog(n)是同阶函数：
　　∵(n/2)n/2≤n!≤nn,∵(n/2)n/2≤n!≤nn,
　　∴n/4log(n)=n/2log(n1/2)≤n/2log(n/2)≤log(n!)≤nlog(n)∴n/4log⁡(n)=n/2log⁡(n1/2)≤n/2log⁡(n/2)≤log⁡(n!)≤nlog⁡(n)
　　所以时间复杂度为**O(nlogn)**

**三.总结**
　　初始化建堆的时间复杂度为O(n)，排序重建堆的时间复杂度为nlog(n)，所以总的时间复杂度为**O(n+nlogn)=O(nlogn)**。另外堆排序的比较次数和序列的初始状态有关，但只是在**序列初始状态为堆的情况下比较次数显著减少**，在**序列有序或逆序的情况下比较次数不会发生明显变化**。

**最优**的情况：所有叶子铺满最底层，什么情况下，数组既是排好的，但建堆过程又不破坏数组呢？那就是**所有元素都相等的情况**，这种情况下堆排序：1）建堆的复杂度不变，是O(n)；2）需进行n-1次交换和heapify，此时heapify由于不用调整，每次复杂度是O(1)，所以总共也是O(n)。所以所有元素相等时，复杂度确实是**O(n)**。

**最差**的情况：所有叶子铺满半层的时候，O(nlogn)

```c++
#include <stdio.h>

void swap(int *a, int *b);
void adjustHeap(int param1,int j, int inNums[]);
void  HeapSort(int nums, int inNums[]);
//大根堆进行调整
void adjustHeap(int param1, int j, int inNums[])
{
    int temp=inNums[param1];
    for (int k=param1*2+1;k<j;k=k*2+1)
    {
        //如果右边值大于左边值，指向右边
        if (k+1<j && inNums[k]< inNums[k+1])
        {
            k++;
        }
        //如果子节点大于父节点，将子节点值赋给父节点,并以新的子节点作为父节点（不用进行交换）
        if (inNums[k]>temp)
        {
            inNums[param1]=inNums[k];
            param1=k;
        }
        else
            break;
    }
        //put the value in the final position
    inNums[param1]=temp;
}
//堆排序主要算法
void HeapSort(int nums,int inNums[])
{
    //1.构建大顶堆
    for (int i=nums/2-1;i>=0;i--)
    {
                //put the value in the final position
        adjustHeap(i,nums,inNums);
    }
    //2.调整堆结构+交换堆顶元素与末尾元素
    for (int j=nums-1;j>0;j--)
    {
                //堆顶元素和末尾元素进行交换
        int temp=inNums[0];
        inNums[0]=inNums[j];
        inNums[j]=temp;

        adjustHeap(0,j,inNums);//重新对堆进行调整
    }
}
int main() {
    int data[] = {6,5,8,4,7,9,1,3,2};
    int len = sizeof(data) / sizeof(int);
    HeapSort(len,data);
    return 0;
}
```



##### 快排

时间复杂度：

1. 最好：O(n log2 n)

   最优情况下，Partition每次都划分得很均匀，如果排序n个关键字，其递归树的深度就为.log2n.+1（.x.表示不大于x的最大整数），即仅需递归log2n次，需要时间为T（n）的话，第一次Partiation应该是需要对整个数组扫描一遍，做n次比较。然后，获得的枢轴将数组一分为二，那么各自还需要T（n/2）的时间（注意是最好情况，所以平分两半）。于是不断地划分下去，我们就有了下面的不等式推断。

   T（n）≤2T（n/2） +n，T（1）=0  
   T（n）≤2（2T（n/4）+n/2） +n=4T（n/4）+2n  
   T（n）≤4（2T（n/8）+n/4） +2n=8T（n/8）+3n  
   ……  
   T（n）≤nT（1）+（log2n）×n= O(nlogn) 
   也就是说，在最优的情况下，快速排序算法的时间复杂度为O(nlogn)。

2. 最坏：O(n^2)

   在最坏的情况下，待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个为空。如果递归树画出来，它就是一棵斜树。此时需要执行n‐1次递归调用，且第i次划分需要经过n‐i次关键字的比较才能找到第i个记录，也就是枢轴的位置，因此比较次数为

   ![img](https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlcy41MWN0by5jb20vZmlsZXMvdXBsb2FkaW1nLzIwMTEwODI2LzIyMjY1MzMwNC5qcGc?x-oss-process=image/format,png) ，最终其时间复杂度为O(n2)。

   平均的情况，设枢轴的关键字应该在第k的位置（1≤k≤n），那么：

   ![img](https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlcy41MWN0by5jb20vZmlsZXMvdXBsb2FkaW1nLzIwMTEwODI2LzIyMjgwMTQ4OS5qcGc?x-oss-process=image/format,png)


   由数学归纳法可证明，其数量级为O(nlogn)。


3. 平均：O(n log2 n)

空间复杂度：O(n log2 n)

就空间复杂度来说，主要是递归造成的栈空间的使用，最好情况，递归树的深度为log2n，其空间复杂度也就为O(logn)，最坏情况，需要进行n‐1递归调用，其空间复杂度为O(n)，平均情况，空间复杂度也为O(logn)。

稳定性：不稳定

```c
template <typename T>
void quick_sort_recursive(T arr[], int start, int end) {
    if (start >= end)
        return;
    T mid = arr[end];
    int left = start, right = end - 1;
    while (left < right) { //在整个范围内搜寻比枢纽元值小或大的元素，然后将左侧元素与右侧元素交换
        while (arr[left] < mid && left < right) //试图在左侧找到一个比枢纽元更大的元素
            left++;
        while (arr[right] >= mid && left < right) //试图在右侧找到一个比枢纽元更小的元素
            right--;
        std::swap(arr[left], arr[right]); //交换元素
    }
    if (arr[left] >= arr[end])
        std::swap(arr[left], arr[end]);
    else
        left++;
    quick_sort_recursive(arr, start, left - 1);
    quick_sort_recursive(arr, left + 1, end);
}
template <typename T> //整數或浮點數皆可使用,若要使用物件(class)時必須設定"小於"(<)、"大於"(>)、"不小於"(>=)的運算子功能
void quick_sort(T arr[], int len) {
    quick_sort_recursive(arr, 0, len - 1);
}
```



##### 希尔排序

希尔排序的复杂度和增量序列是相关的（希尔排序时间bai复杂度的指数具体数值目前是比较模糊du的，并没有zhi一个统一的取值，它取决于增量。但已dao知的就是指数不是平方级的，即不是O(n^2)，而是O(n^m(1<m<2))也就是说指数m不会大于等于2是介于[1,2)半闭半开区间。）

{1,2,4,8,...}这种序列并不是很好的增量序列，使用这个增量序列的时间复杂度（最坏情形）是**O(n^2)**

Hibbard提出了另一个增量序列{1,3,7，...,2^k-1}，这种序列的时间复杂度(最坏情形)为**O(n^1.5)**

Sedgewick提出了几种增量序列，其最坏情形运行时间为**O（n^1.3**）,其中最好的一个序列是{1,5,19,41,109,...}

```c++
template<typename T>
void shell_sort(T array[], int length) {
    int h = 1;
    while (h < length / 3) {
        h = 3 * h + 1;
    }
    while (h >= 1) {
        for (int i = h; i < length; i++) {
            for (int j = i; j >= h && array[j] < array[j - h]; j -= h) {
                std::swap(array[j], array[j - h]);
            }
        }
        h = h / 3;
    }
}
```

##### 归并排序

假设函数MergeSort需要时间T(N)。因为Merge()函数的时间复杂度为O(N)，所T(N)=2*T(N/2)+O(N)。推导得时间复杂度均为O(N*logN)。或者这么理解：归并排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它的时间复杂度是**O(N*logN)**。



```c++
//自顶向下
#include <iostream>
using namespace std;

//合并两个有序数组的操作
//索引m是第二区间的左边界
void merge(int *a, int l, int m, int r) {
	int LEFT_SZIE  = m - l;
	int RIGHT_SIZE = r - m + 1;
	int *left  = new int[LEFT_SIZE];
	int *right = new int[RIGHT_SIZE];
	for(int i=l; i<m; ++i) left[i-l] = a[i];
	for(int i=m; i<=r; ++i) right[i-m] = a[i];
	int i=0, j=0, k=l;
	while(i < LEFT_SZIE && j < RIGHT_SIZE) {
		if(left[i] < right[j]) a[k ++] = left[i ++];
		ekse a[k ++] = right[j ++];
	}
	while(i < LEFT_SIZE)  a[k ++] = left[i ++];
	while(j < RIGHT_SIZE) a[k ++] = right[j ++];


	delete[] left;
	delete[] right;
}

void _mergeSort(int *a, int l, int r) {
	if(l >= r) return;
	int m = (r - l) / 2 + l;
	_mergeSort(a, l, m);
	_mergeSort(a, m+1, r);
	merge(a, l, m+1, r);
}


void mergeSort(int *a, int n) {
	_mergeSort(a, 0, n-1);
}
```

**自底向上**的归并排序算法的思想就是数组中先一个一个归并成两两有序的序列，两两有序的序列归并成四个四个有序的序列，然后四个四个有序的序列归并八个八个有序的序列，以此类推，直到，归并的长度大于整个数组的长度，此时整个数组有序。需要注意的是数组按照归并长度划分，最后一个子数组可能不满足长度要求，这个情况需要特殊处理。自顶下下的归并排序算法一般用递归来实现，而自底向上可以用循环来实现。

```c
//merge操作和上边是一样的
//这种实现方式参考算法四的实现
void _mergeSortBU(int *a, int n) {
	for(int sz=1; sz<n; sz+=sz) 
		//对a[i...i+sz-1]和a[i+sz....i+2*sz-1]进行归并
        /*(1)为了保证由两个归并段i+sz < n
          (2)为了保证不越界 min(i+2*sz-1, n-1)*/
		for(int i=0; i+sz<n; i+=sz+sz) 
			merge(a, i, i+sz, min(i+sz+sz-1, n-1));
}

void mergeSortBU(int *a, int n) {
	_mergeSortBU(a, n);
}
```

**迭代**

```c++
template<typename T> // 整數或浮點數皆可使用,若要使用物件(class)時必須設定"小於"(<)的運算子功能
void merge_sort(T arr[], int len) {
    T *a = arr;
    T *b = new T[len];
    for (int seg = 1; seg < len; seg += seg) {
        for (int start = 0; start < len; start += seg + seg) {
            int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);
            int k = low;
            int start1 = low, end1 = mid;
            int start2 = mid, end2 = high;
            while (start1 < end1 && start2 < end2)
                b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];
            while (start1 < end1)
                b[k++] = a[start1++];
            while (start2 < end2)
                b[k++] = a[start2++];
        }
        T *temp = a;
        a = b;
        b = temp;
    }
    if (a != arr) {
        for (int i = 0; i < len; i++)
            b[i] = a[i];
        b = a;
    }
    delete[] b;
}
```

**递归**

```

```

##### 冒泡排序

```c++
//假设排序arr[] = { 1, 3, 4, 2, 6, 7, 8, 0 };
void BubbleSort(int arr[],int len)
{
	int i = 0;
	int tmp = 0;
	for (i = 0; i < len - 1; i++)//确定排序趟数
	{
		int j = 0;
		for (j = 0; j < len - 1 - i; j++)//确定比较次数
		{
			if (arr[j]>arr[j + 1])
			{
				//交换
				tmp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = tmp;
			}
		}
	}
}
```

优化一

假设我们现在排序ar[]={1,2,3,4,5,6,7,8,10,9}这组数据，按照上面的排序方式，第一趟排序后将10和9交换已经有序，接下来的8趟排序就是多余的，什么也没做。所以我们可以在交换的地方加一个标记，如果那一趟排序没有交换元素，说明这组数据已经有序，不用再继续下去。

```c
void BubbleSort(int arr[], int len)
{
	int i = 0;
	int tmp = 0;
	for (i = 0; i < len - 1; i++)//确定排序趟数
	{
		int j = 0;
		int flag = 0;
		for (j = 0; j < len - 1 - i; j++)//确定比较次数
		{
			if (arr[j]>arr[j + 1])
			{
				//交换
				tmp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = tmp;
				flag = 1;//加入标记
			}
		}
		if (flag == 0)//如果没有交换过元素，则已经有序
		{
			return;
		}
	}
}

```

优化二

优化一仅仅适用于连片有序而整体无序的数据(例如：1， 2，3 ，4 ，7，6，5)。但是对于前面大部分是无序而后边小半部分有序的数据(1，2，5，7，4，3，6，8，9，10)排序效率也不可观，对于种类型数据，我们可以继续优化。既我们可以记下最后一次交换的位置，后边没有交换，必然是有序的，然后下一次排序从第一个比较到上次记录的位置结束即可。

```c++
void BubbleSort(int arr[], int len)
{
	int i = 0;
	int tmp = 0;
	int flag = 0;
	int pos = 0;//用来记录最后一次交换的位置
	int k = len - 1;
	for (i = 0; i < len - 1; i++)//确定排序趟数
	{
		pos = 0;
		int j = 0;
		flag = 0;
		for (j = 0; j < k; j++)//确定比较次数
		{
			if (arr[j]>arr[j + 1])
			{
				//交换
				tmp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = tmp;
				flag = 1;//加入标记
				pos = j;//交换元素，记录最后一次交换的位置
			}
		}
		if (flag == 0)//如果没有交换过元素，则已经有序
		{
			return;
		}
		k = pos;//下一次比较到记录位置即可
	}
}
```

优化三

优化二的效率有很大的提升，还有一种优化方法可以继续提高效率。大致思想就是一次排序可以确定两个值，正向扫描找到最大值交换到最后，反向扫描找到最小值交换到最前面。例如：排序数据1，2，3，4，5，6，0

```c
void BubbleSort(int arr[], int len)
{
	int i = 0;
	int j = 0;
	int n = 0;//同时找最大值的最小需要两个下标遍历
	int flag = 0;
	int pos = 0;//用来记录最后一次交换的位置
	int k = len - 1;
	for (i = 0; i < len - 1; i++)//确定排序趟数
	{
		pos = 0;
		flag = 0;
		//正向寻找最大值
		for (j = n; j < k; j++)//确定比较次数
		{
			if (arr[j]>arr[j + 1])
			{
				//交换
				int tmp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = tmp;
				flag = 1;//加入标记
				pos = j;//交换元素，记录最后一次交换的位置
			}
		}
		if (flag == 0)//如果没有交换过元素，则已经有序,直接结束
		{
			return;
		}
		k = pos;//下一次比较到记录位置即可
		//反向寻找最小值
		for (j = k; j > n; j--)
		{
			int tmp = arr[j];
			arr[j] = arr[j - 1];
			arr[j - 1] = tmp;
			flag = 1;
		}
		n++;
		if (flag == 0)//如果没有交换过元素，则已经有序,直接结束
		{
			return;
		}
	}
}
```

##### 选择排序

**性能分析：**

交换元素的代码写在内循环之外，每次交换都能排定一个元素，因此交换的总次数是 N。所以算法的**时间效率**取决于**比较的次数**。

简单选择排序它最大的特点是交换移动数据次数相当少，这样也就节约了相应的时间，无论最好最坏的情况，其比较次数都是一样多。第 i 次排序需要进行n-i 次关键字的比较，此时需要比较n-1+n-2+...+1=**n(n-1)/2**次，时间复杂度为**O（n^2)**。对于交换次数而言，当最好的时候，交换为0次，最差的时候，也就初始排序，交换次数为n-1次,复杂度为**O（n)**。

**选择排序的特点**：

①、**运行时间和输入无关**。为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供什么信息；
 ②、**数据移动是最小的**。每次交换都会改变两个数组元素的值，因此选择排序用了 N 次交换——交换次数和数组的大小是线性关系。（其他大部分排序算法的增长数量级都是线性对数或是平方级别的）

```c
template<typename T> //整數或浮點數皆可使用，若要使用物件（class）時必須設定大於（>）的運算子功能
void selection_sort(std::vector<T>& arr) {
        for (int i = 0; i < arr.size() - 1; i++) {
                int min = i;
                for (int j = i + 1; j < arr.size(); j++)
                        if (arr[j] < arr[min])
                                min = j;
                std::swap(arr[i], arr[min]);
        }
}
```

优化

述方案中的主要思路是，每次遍历剩余元素，找出其中最小值，只排定最小值。（原有方案）

我们这样，每次遍历剩余元素的时候，找出其中最小值和最大值，并排定最小值和最大值。（优化方案）

这样遍历的次数会减少一半。时间复杂度是**O（N/2 * N /2）**，还是平方级别的。但是运行时间有了相应的减少。

```java
public static void sortPlus(Comparable[] arr) {
    for (int left = 0, right = arr.length - 1; left < right; left++, right--) {
        int min = left;        // 记录最小值
        int max = right;     // 记录最大值
        for (int index = left; index <= right; index++) {
            if (less(arr[index], arr[min])) {
                min = index;
            }
            if (less(arr[max], arr[index])) {
                max = index;
            }
        }
        // 将最小值交换到 left 的位置
        exch(arr, left, min);
        //此处是先排最小值的位置，所以得考虑最大值（arr[max]）在最小位置（left）的情况。
        if (left == max) {
            max = min;
        }
        exch(arr, right, max);
    }
}
```

##### 插入排序

**直接插入排序：**

时间复杂度为O（n^2）稳定的排序元素移动是顺序的

在一个数组中，将第一个元素看作排序元素序列里的唯一元素，然后用临时变量tmp首先存放第二元素,即可在数组中空第二个元素位置（即此位置可被覆盖），

将第二个元素与有序序列里面唯一一个元素进行比较，根据排序条件决定元素是否需要向后移动，然后有序序列元素加一，申请空间里面存放将要插进有序序列里面的元素；

```c

void InsertSort(int arr[], int start, int end)
{
	int tmp = arr[start];
	for (int i = start+1; i <= end; ++i)
	{
		tmp = arr[i];
		int j = i - 1;
		while (j >= start && arr[j] > tmp)
		{
			arr[j + 1] = arr[j];
			--j;
		}
		arr[j + 1] = tmp;
        }

```

优化

**折半插入排序**（Binary Insertion Sort）是对插入排序算法的一种改进，所谓排序算法过程，就是不断的依次将元素插入前面已排好序的序列中，在寻找插入点时采用了折半查找。时间复杂度：O(n^2)，稳定性：稳定。

排序思想：有一组数据待排序，排序区间为Array[0]~Array[n-1]。将数据分为有序数据和无序数据，第一次排序时默认Array[0]为有序数据，Array[1]~Array[n-1]为无序数据。有序数据分区的第一个元素位置为low，最后一个元素的位置为high。

 遍历无序区间的所有元素，每次取**无序区间**的第一个元素Array[i]，因为0~i-1是有序排列的，所以用中点m将其平分为两部分，然后将待排序数据同中间位置为m的数据进行比较，若待排序数据较大，则low~m-1分区的数据都比待排序数据小，反之，若待排序数据较小，则m+1~high分区的数据都比 待排序数据大，此时将low或high重新定义为新的合适分区的边界，对新的小分区重复上面操作。直到low和high 的前后顺序改变，此时high+1所处位置为待排序数据的合适位置。

```c++
void binary_insert_sort(int arr[], int len) 
{
        int i, j, temp, m, low, high;
        for (i = 1; i < len; i++)
        {
               temp = arr[i];
               low = 0; high = i-1;
               while (low <= high)
               {
                      m = (low +high) / 2;
                      if(arr[m] > temp)
                               high = m-1;
                      else
                               low = m+1;
               }
               for (j = i-1; j>=high+1; j--)
                      arr[j+1] = arr[j];
       }
       arr[j+1] = temp;
}
```

##### 计数排序

 基本思想

计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。

计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），然后进行分配、收集处理：

> ① **分配**。扫描一遍原始数组，以当前值-minValue作为下标，将该下标的计数器增1。
> ② **收集**。扫描一遍计数器数组，按顺序把值收集起来。

实现逻辑

> ① 找出待排序的数组中最大和最小的元素
> ② 统计数组中每个值为i的元素出现的次数，存入数组C的第i项
> ③ 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
> ④ 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去

复杂度分析

> 平均时间复杂度：O(n + k)
> 最佳时间复杂度：O(n + k)
> 最差时间复杂度：O(n + k)
> 空间复杂度：O(n + k)

当输入的元素是n 个**0到k**之间的整数时，它的运行时间是 O(n + k)。。在实际工作中，当k=O(n)时，我们一般会采用计数排序，这时的运行时间为O(n)。

计数排序需要两个额外的数组用来对元素进行计数和保存排序的输出结果，所以空间复杂度为O(k+n)。

计数排序的一个重要性质是它是稳定的：具有相同值的元素在输出数组中的相对次序与它们在输入数组中的相对次序是相同的。也就是说，对两个相同的数来说，在输入数组中先出现的数，在输出数组中也位于前面。

计数排序的稳定性很重要的一个原因是：计数排序经常会被用于基数排序算法的一个子过程。我们将在后面文章中介绍，为了使基数排序能够正确运行，计数排序必须是稳定的。

```c
#include <time.h>
void print_arr(int *arr, int n) {
    int i;
    printf("%d", arr[0]);
    for (i = 1; i < n; i++)
        printf(" %d", arr[i]);
    printf("\n");
}
void counting_sort(int *ini_arr, int *sorted_arr, int n) {
    int *count_arr = (int *) malloc(sizeof(int) * 100);
    int i, j, k;
    for (k = 0; k < 100; k++)
        count_arr[k] = 0;
    for (i = 0; i < n; i++)
        count_arr[ini_arr[i]]++;
    for (k = 1; k < 100; k++)
        count_arr[k] += count_arr[k - 1];
    for (j = n; j > 0; j--)
        sorted_arr[--count_arr[ini_arr[j - 1]]] = ini_arr[j - 1];
    free(count_arr);
}
```

**优化**

**场景分析：**举个极端的例子：如果排序的数组有200W个元素，但是这200W个数的值都在1000000-1000100，也就说有100个数，总共重复了200W次，现在要排序，怎么办？

这种情况排序，计数排序应该是首选。但是这时候n的值为200W，如果按原来的算法，k的值10001000，但是此时c中真正用到的地方只有100个，这样对空间造成了极大的浪费。

**改进思路：**针对c数组的大小，优化计数排序

```c++
public class CountSort{
    public static void main(String []args){
        //排序的数组
        int a[] = {100, 93, 97, 92, 96, 99, 92, 89, 93, 97, 90, 94, 92, 95};
        int b[] = countSort(a);
        for(int i : b){
            System.out.print(i + "  ");
        }
        System.out.println();
    }
    public static int[] countSort(int []a){
        int b[] = new int[a.length];
        int max = a[0], min = a[0];
        for(int i : a){
            if(i > max){
                max = i;
            }
            if(i < min){
                min = i;
            }
        }
        //这里k的大小是要排序的数组中，元素大小的极值差+1
        int k = max - min + 1;
        int c[] = new int[k];
        for(int i = 0; i < a.length; ++i){
            c[a[i]-min] += 1;//优化过的地方，减小了数组c的大小
        }
        for(int i = 1; i < c.length; ++i){
            c[i] = c[i] + c[i-1];
        }
        for(int i = a.length-1; i >= 0; --i){
            b[--c[a[i]-min]] = a[i];//按存取的方式取出c的元素
        }
        return b;
    }
}
```

##### 桶排序

桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后依次把各个桶中的记录列出来记得到有序序列。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ(n)）。但桶排序并不是比较排序，他不受到O(n log n)下限的影响。

**基本思想**

桶排序的思想近乎彻底的**分治思想**。

桶排序假设待排序的一组数均匀独立的分布在一个范围中，并将这一范围划分成几个子范围（桶）。

然后基于某种映射函数f ，将待排序列的关键字 k 映射到第i个桶中 (即桶数组B 的下标i) ，那么该关键字k 就作为 B[i]中的元素 (每个桶B[i]都是一组大小为N/M 的序列 )。

接着将各个桶中的数据有序的合并起来 : 对每个桶B[i] 中的所有元素进行比较排序 (可以使用快排)。然后依次枚举输出 B[0]….B[M] 中的全部内容即是一个有序序列。

> 补充： 映射函数一般是 f = array[i] / k; k^2 = n; n是所有元素个数

为了使桶排序更加高效，我们需要做到这两点：

> 1、在额外空间充足的情况下，尽量增大桶的数量；
> 2、使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中；

同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。

 **实现逻辑**

- 设置一个定量的数组当作空桶子。
- 寻访序列，并且把项目一个一个放到对应的桶子去。
- 对每个不是空的桶子进行排序。
- 从不是空的桶子里把项目再放回原来的序列中。

 **什么时候最快**

当输入的数据可以均匀的分配到每一个桶中。

**什么时候最慢**

当输入的数据被分配到了同一个桶中。

```c
//假设数据分布在[0，100)之间，每个桶内部用链表表示，在数据入桶的同时插入排序。然后把各个桶中的数据合并。
const int BUCKET_NUM = 10;
struct ListNode{
	explicit ListNode(int i=0):mData(i),mNext(NULL){}
	ListNode* mNext;
	int mData;
};
ListNode* insert(ListNode* head,int val){
	ListNode dummyNode;
	ListNode *newNode = new ListNode(val);
	ListNode *pre,*curr;
	dummyNode.mNext = head;
	pre = &dummyNode;
	curr = head;
	while(NULL!=curr && curr->mData<=val){
		pre = curr;
		curr = curr->mNext;
	}
	newNode->mNext = curr;
	pre->mNext = newNode;
	return dummyNode.mNext;
}
ListNode* Merge(ListNode *head1,ListNode *head2){
	ListNode dummyNode;
	ListNode *dummy = &dummyNode;
	while(NULL!=head1 && NULL!=head2){
		if(head1->mData <= head2->mData){
			dummy->mNext = head1;
			head1 = head1->mNext;
		}else{
			dummy->mNext = head2;
			head2 = head2->mNext;
		}
		dummy = dummy->mNext;
	}
	if(NULL!=head1) dummy->mNext = head1;
	if(NULL!=head2) dummy->mNext = head2;
	
	return dummyNode.mNext;
}
void BucketSort(int n,int arr[]){
	vector<ListNode*> buckets(BUCKET_NUM,(ListNode*)(0));
	for(int i=0;i<n;++i){
		int index = arr[i]/BUCKET_NUM;
		ListNode *head = buckets.at(index);
		buckets.at(index) = insert(head,arr[i]);
	}
	ListNode *head = buckets.at(0);
	for(int i=1;i<BUCKET_NUM;++i){
		head = Merge(head,buckets.at(i));
	}
	for(int i=0;i<n;++i){
		arr[i] = head->mData;
		head = head->mNext;
	}
}
```

##### 基数排序

 **基本思想**

原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。

- **MSD**：先从高位开始进行排序，在每个关键字上，可采用计数排序
- **LSD**：先从低位开始进行排序，在每个关键字上，可采用桶排序

**实现逻辑**

> ① 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。
> ② 从最低位开始，依次进行一次排序。
> ③ 这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。

设有数组 array = {53, 3, 542, 748, 14, 214, 154, 63, 616}，对其进行基数排序：

![preview](https://pic4.zhimg.com/v2-5ae4857fa248035ecec780583c5e3303_r.jpg)

在上图中，首先将所有待比较数字统一为统一位数长度，接着从最低位开始，依次进行排序。

- 按照个位数进行排序。
- 按照十位数进行排序。
- 按照百位数进行排序。

排序后，数列就变成了一个有序序列。

**复杂度分析**

> 时间复杂度：O(k*N)
> 空间复杂度：O(k + N)
> 稳定性：稳定

设待排序的数组**R[1..n]**，数组中最大的数是**d**位数，基数为**r**（如基数为10，即10进制，最大有10种可能，即最多需要10个桶来映射数组元素）。

处理一位数，需要将数组元素映射到r个桶中，映射完成后还需要收集，相当于遍历数组一遍，最多元素数为n，则时间复杂度为O(n+r)。所以，总的时间复杂度为O(d*(n+r))。

基数排序过程中，用到一个计数器数组，长度为r，还用到一个r*n的二位数组来做为桶，所以空间复杂度为O(r*n)。

基数排序基于分别排序，分别收集，所以是稳定的。

```c
int maxbit(int data[], int n) //辅助函数，求数据的最大位数
{
    int maxData = data[0];      ///< 最大数
    /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。
    for (int i = 1; i < n; ++i)
    {
        if (maxData < data[i])
            maxData = data[i];
    }
    int d = 1;
    int p = 10;
    while (maxData >= p)
    {
        //p *= 10; // Maybe overflow
        maxData /= 10;
        ++d;
    }
    return d;
/*    int d = 1; //保存最大的位数
    int p = 10;
    for(int i = 0; i < n; ++i)
    {
        while(data[i] >= p)
        {
            p *= 10;
            ++d;
        }
    }
    return d;*/
}
void radixsort(int data[], int n) //基数排序
{
    int d = maxbit(data, n);
    int *tmp = new int[n];
    int *count = new int[10]; //计数器
    int i, j, k;
    int radix = 1;
    for(i = 1; i <= d; i++) //进行d次排序
    {
        for(j = 0; j < 10; j++)
            count[j] = 0; //每次分配前清空计数器
        for(j = 0; j < n; j++)
        {
            k = (data[j] / radix) % 10; //统计每个桶中的记录数
            count[k]++;
        }
        for(j = 1; j < 10; j++)
            count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶
        for(j = n - 1; j >= 0; j--) //将所有桶中记录依次收集到tmp中
        {
            k = (data[j] / radix) % 10;
            tmp[count[k] - 1] = data[j];
            count[k]--;
        }
        for(j = 0; j < n; j++) //将临时数组的内容复制到data中
            data[j] = tmp[j];
        radix = radix * 10;
    }
    delete []tmp;
    delete []count;
}
```

基数排序与计数排序、桶排序这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：

- 基数排序：根据键值的每位数字来分配桶；
- 计数排序：每个桶只存储单一键值；
- 桶排序：每个桶存储一定范围的数值；

基数排序不是直接根据元素整体的大小进行元素比较，而是将原始列表元素分成多个部分，对每一部分按一定的规则进行排序，进而形成最终的有序列表。



### 笔记

#### 767、重构字符串c

```c
//记录字母数并降序排列,pair排序
#define forp(i,s,n) for(int i=(s);i<(n);i++)

vector<pair<char,int>> h(26,make_pair('a',0));
        
for(int i=0;i<26;i++)
     h[i].first+=i;
for(char p:S)
    h[p-'a'].second++;
sort(h.begin(),h.end(),[](pair<char,int> a,pair<char,int> b){return a.second>b.second;});
```



#### 524、通过删除字母匹配到字典里最长单词

```c++
//a按字典升序
vector<string> a;
sort(a.begin(),a.end(),[](auto a,auto b){return a.size()>b.size() || a.size()==b.size()&&a<b;});
```





### 题解

##### 215、数组中的第K个最大元素

1、快排

2、小顶堆（优先队列）

##### 347、前k个高频元素

1、小顶堆

##### 692、前k个高频单词

