P76、字符串直接初始化和拷贝初始化

P88、列表初始化vector对象

 

问题：

6.2.3 const形参和实参

6.3.3 返回数组指针

6.7 函数指针

7.3.2 返回*this的成员函数

7.5.4 隐式的类类型转换

12.1.6 weak_ptr

 

15.7.2 合成拷贝控制与继承

15.7.3 派生类的拷贝控制成员

15.7.4 继承的构造函数

 

15.8 容器与继承



2.2.1 列表初始化、默认初始化

2.3.1 引用

2.3.2 指针

void* 指针、指向指针的指针、指向指针的引用

2.4 const

常量引用、指向常量的指针和常量指针、顶层和底层const、constexpr

2.5.3 decltype



3.1 using 声明

3.2.1 string的直接初始化和拷贝初始化

3.2.2 string对象和字面值相加

3.2.3 使用for语句改变字符串中的字符

3.3 不存在包含引用的vector

3.3.1 列表初始化vector对象

3.4.1 尾迭代器、返回迭代器所指元素的引用（*item）、解引用（item->mem）

解引用 (*item).mem

修改当前字符 *it = toupper( *it )

迭代器类型 iterator、const_iterator

cbegin、cend

it->mem和(*it).mem意思相同，->把解引用和成员访问结合在一起

不能在for循环中像vector添加元素

3.4.2 迭代器运算

difference_type

3.5.1 常量表达式初始化数组（constexpr）

字符数组中的空字符

不允许拷贝和赋值

不存在引用的数组

int *ptrs[10];     int *(&array)[10] = ptrs;

3.5.2 size_t类型

3.5.3 指针和数组

string nums[] = {};  string *p = &nums[0]; <=> string *p = nums;

int ia[] = {}; auto ia1(ia); auto ia2(&ia[0]); 

使用decltype时，decltype(ia) ia3 = {};

指针也是迭代器：int arr[] = {}; int *p = arr; ++p; 

不能对尾后指针执行解引用或递增

指针运算: ptrdiff_t类型

3.5.5 c_str()函数

3.6 多维数组的下标引用

用for语句处理多维数组，把控制变量声明成引用类型

指针和多维数组：

int ia[3] [4];

int (*p)[4] = ia; p = &ia[2];

int *p[4] = ia; 



**4.1.1 左值和右值**

左值表达式

decltype和左值、右值（p 是 int*, 则decltype( *p) 是 int&, decltype( *p) 是int**）

int a[] = {}; int last = *(a+4); last = *ia + 4;

4.2 商一定向0取整，-21 % -8 = -5；21 % -5 = 1；21 % -5 = -4；

**4.5 递增和递减**

j = i++;

j = ++i;

混用解引用和递增：*pbeg++ <=> *(pbeg++)

4.6 成员访问运算符

ptr->mem 结果是左值

<=> (*ptr).mem 结果依据成员所属对象

**4.8 位运算符**

**4.9 sizeof运算符**

sizeof *p;

sizeof运算符的结果部分依赖于其作用的类型

**4.11 类型转换**

隐式类型转换

算术转换

其他隐式类型转换：数组转换成指针

显示转换：reinterpret_cast、static_cast、const_cast、dynamic_cast 

explicit



5.3.1 悬垂else

5.3.2 switch内部的控制流

switch**内部变量定义**：case中含有变量

5.4.2 **for循环的执行流程**：最后执行expression

5.4.3 **范围for语句**：对元素执行写操作，循环变量必须声明成引用类型

5.6 try

throw



6.1 ret *= val--;

函数的返回类型：不能是数组，可以是指向函数和数组的指针

6.1.1 局部变量、自动对象

**局部静态对象** static

6.2 参数传递

形参是引用类型：引用传递、传引用调用

实参的值拷贝给形参：值传递、传值调用

指针形参：

```c++
int n = 0;
int *p = &n;
*p = 42;	// n值改变，p值不变

void reset(int *p){
    *p = 0;  //改变指针p所指向的对象的值
    p = 0;   // 只改变了p的局部拷贝，实参未被改变
}
int i = 32;
reset(&i);
cout << i ; // i = 0
```

使用引用形参返回多个值

6.2.3 const形参和实参

顶层const作用于对象本身：

```c++
const int ci = 43; // 不能改变ci,const是顶层的
int i = ci;  // 拷贝ci时，忽略它的顶层const
int * const p = &i; // const是顶层的，不能给p赋值
*p = 0;  // 通过p改变对象的内容是允许的，现在i变成了0

void func(const int i) { ... } //实参初始化形参时会忽略顶层cosnt,可以读取i但不能向i写值
void func(int i) { ... } // 重复定义 func
```

指针或引用形参与const

用字面值初始化常量引用

用非常量初始化底层const对象

不能把const对象、字面值或需要类型转换的对象传递给普通的引用形参

6.2.4 数组形参

不允许拷贝数组、无法使用值传递的方式使用数组参数、使用数组时将其转换为指针

传递数组时传递指向数组首元素的指针

```c++
//每个函数都有一个const int*类型的形参
void 
void
void 
    

```

int i = 0; printf(&i); &i类型是int *

const int ia[] <=> const int *ia

只用函数要改变元素值的时候，才把形参定义成指向非常量的指针

数组引用形参：f(int (&arr)[10]) arr是有10个整数的整型**数组的引用**

​							f(int &arr[10]) 将arr声明成**引用的数组**

传递多维数组：int *matrix[10] 10个指针构成的数组

​							int (*matrix)[10] 指向含有10个整数的数组的指针

6.2.6 含有可变形参的函数

inintializer list形参

6.3.2 值是如何被返回的：函数返回引用，该引用仅是他所引用对象的一个别名，不会真正拷贝

不要返回局部对象的引用或指针

调用返回引用的函数得到左值，其他返回类型得到右值

返回的常量引用，不能给调用的结果赋值

列表初始化返回值：可以返回括号包围的值的列表

主函数main:两个预处理变量EXIT_FILURE、EXIT_SUCCESS

mian函数不能调用自己

**6.3.3 返回数组指针**

**返回数组的指针或引用（使用类型别名）**

**不使用类型别名：声明一个返回数组指针的函数：int (*func(int i)[10]);		?**

**尾置返回类型：auto func(int i)-> int (*)[10];**

**使用decltype**

6.4 函数重载

main不能重载

不允许两个函数除了返回类型外其他所有的要素都相同

重载和const形参：拥有顶层const的形参无法和没有const的形参区分 record lookup(phone);

​																													   record lookup(const phone);

如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现重载，此时const是底层的：record lookup(account &);

​							record lookup(const account&);

record lookup(account *);

record lookup(const account*);

**const_cast 和重载：**

6.5.1 默认实参

局部变量与传递给函数的默认实参没有任何关系

6.5.2 内联函数可以避免函数调用的代价

**constexpr函数：能用于常量表达式的函数		？**

**常量表达式**

6.5.3 assert预处理宏

如果NDEBUG预处理变量未定义，将执行#ifndef和#endif之间的代码

_ _ func _ _ 、 _ _FILE _ _ 、 _ _ LINE _ _ 、 _ _ TIME _ _ 、 _ _ DATE _ _

6.6 函数匹配

候选函数和可行函数

6.6.1 实参类型转换

**编译器将实参类型到形参类型转换的等级：1-5**

所有算术类型转换类型级别都一样，从int到unsigned int和从int 到double级别一样

**6.7 函数指针**

**重载函数的指针**

**函数指针形参**

**类型别名和decltype简化函数指针的使用		？**

**返回指向函数的指针**



7.1.2 定义在类内部的函数是隐式的内联函数

**引入this:调用成员函数时，实际上是替某个对象调用它**

**任何对类成员的直接访问都被看做this的隐式引用 total.isbn() => Sale_data::isbn(&total) => this->bookNo**

**this是常量指针，不允许改变this中保存的地址**

**引入const成员：紧随在参数列表后的const，修改隐式this指针的类型**

默认情况下，this是指向类类型非常量版本的常量指针，如Sales_data *const，不能把this绑定到一个常量对象上

常量成员函数

**常量对象，以及常量对象的引用或指针都只能调用常量成员函数**

编译器处理类：先编译成员说明，然后成员函数体

**定义返回this对象的函数：return *this返回的是当前对象的克隆或者本身（若返回类型为A， 则是克隆， 若返回类型为A&， 则是本身，而非副本）。return this返回当前对象的地址（指向当前对象的指针）**

```c++
 Test()
 { 
  return this; //返回的当前对象的地址
 }
 Test&()
 { 
  return *this; //返回的是当前对象本身,这类函数通常返回类型是所属类的引用,经过 *this的解引用后成为此对象本身
 }
 Test()
 { 
  return *this; //返回的当前对象(*this)的克隆
 }
```

7.1.3 IO类属于不能被拷贝的类型，只能通过引用传递他们：istream &read(){}

ostream &print(){}

7.1.4 构造函数

**构造函数没有返回类型，不能被声明成const**

**默认构造函数无需任何实参**

合成的默认构造函数

**某些类不能依赖合成的默认构造函数：**

- 如果一个类需要控制对象初始化，很可能在所有情况下都需要控制
-  定义在块中的内置类型或复合类型的对象被默认初始化，他们的值将是未定义的（数组、指针）
- 类中含其他类类型成员且没有默认构造函数，编译器无法初始化该成员

Sales_data() = defaule; 要求编译器生成构造函数

= default在类内部，默认构造函数时内联的，在外部则不是内联的

构造函数初始值列表

某个数据成员被构造函数初始值列表忽略时，它将与合成默认构造函数相同的方式隐式初始化

类内初始值初始化

**在类的外部定义构造函数			?**

**7.1.5 对象在几种情况下会被拷贝：**

- 初始化变量以及以值的方式传递或返回一个对象
- 使用了赋值运算符
- 对象不再存在时执行销毁的操作  ，如局部对象         ？

class(private)和struct(public)的默认访问权限不一样

友元允许访问**非公有成员**

7.3.1 **可变数据成员mutable,即使在一个const对象内也能被修改**

7.3.2 返回*this的成员函数

**从cosnt成员函数返回*this**：一个const成员函数如果以引用的形式返回 *this,他的返回类型将是常量引用        					**（重要）**

**基于const的重载**

```c++
screen &display(std::ostream &os)
	{return *this;}
//this
const screen &display(std:;ostream &os) const
	{return *this;}
//this是指向const的指针，*this是const对象，返回类型必须是const &screen常量引用,如果令display返回一个const引用，则调用myscreen.display(cout).set('*')会引发错误，无法set一个常量引用
//可以在非常量版本上调用常量或非常量版本
void do_display(std::ostream &os) const 
	{os << contents;}
```

7.3.3 前向声明

不完全类型

一旦一个类的名字出现后，他就被认为是声明过了，类允许包含指向自身类型的引用或指针

```c++
class Link_screen {
	Screen window;
	Link_screen *next;
	Link_screen *prev;
}
```

7.3.4

类可以把其他类，其他类之前已经定义过的成员函数定义成友元

友元函数能定义在类的内部，这样的函数是隐式内联的

**令成员函数作为友元，函数必须在类之前被声明但不能被定义**

7.4.1 内层作用域可以重新定义外层作用域中的名字

**成员函数中使用的名字的解析方式: 1、2、3**

7.5.1 构造函数初始值必不可少：					**(重要)**

- **成员是const、引用**
- **属于某种未提供默认构造函数的类类型**

初始化和赋值的区别事关底层效率：前者直接初始化数据成员，后者**先初始化再赋值**

```c++
//最好令构造函数初始值的顺序和成员声明的顺序一致
class X{
	int i;
	int j;
public:
	X(int cal): j(val), i(j){}
}
//i先被初始化，且试图使用未定义的值j初始化i
```

默认实参和构造函数            ？

```c++
Sale_data(std::string s = ""): bookNo(s) {}
```

7.5.2 委托构造函数

使用它所属类的其他构造函数执行它自己的初始化过程

**7.5.3 默认构造函数**  							**(重要)**

当对象被**默认初始化或值初始化**时自动执行默认构造函数，

发生默认初始化的情况:

- 在块作用域内不使用任何初始值定义一个非静态变量

- 类本身含有类类型的成员且使用合成的默认构造函数

- 类类型的成员没有在构造函数初始值列表中显示的初始化

发生值初始化:

- 数组初始化的过程中提供的初始值数量小于数组的大小

- 不使用初始值定义一个静态变量时

- 通过形如T( )的表达式显示的请求值初始化时

**7.5.4 隐式的类类型转换**                              **(重要)**          

转换构造函数

**能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则**

```c++
//在Sale_data类中，接受string的构造函数和接受istream的构造函数分别定义了从这两种类型向Sale_data隐式转换的规则
string null_book = "999999";
item.combine(null_book);
//用一个string实参调用了Sale_data的combine成员，编译器用给定的string自动的创建了一个Sale_data对象，这个临时的对象被传递给combine,combine的参数是常量引用，所以可以给该参数传递一个临时量
```

只允许一步类类型转换

抑制构造函数定义的隐式转换：explicit,只对一个实参的构造函数有效，只允许出现在类内的构造函数声明处

```c++
explicit Sale_date(std::istream &);
```

explicit构造函数只能用于直接初始化，不能用于拷贝形式的初始化(=)

```c++
Sale_data item(null_book);	//√
Sale_data item2 = null_book;	//×
```

可以使用explicit的构造函数显示的强制进行转换

```c++
item.combine(static_cast<Sale_data>(cin));//static_cast使用istream构造函数创建了一个临时的Sale_data对象
```

标准库中含显示构造函数的类：

接受一个单参数的const char*的string的构造函数不是explicit的，

接受一个容量参数的vector构造函数是explicit的

7.5.5 **聚合类**（1、2、3、4个条件）

7.5.6 **字面值常量类**                                                     **？？？？**

类可能含有constexpr函数成员，这样的成员必须符合constexpr函数所有的要求，他们是隐式的

数据成员都是字面值类型的聚合类是字面值常量类

或符合（1、2、3、4）

字面值常量类的构造函数可以是constexpr函数，可以声明成=default形式或删除函数形式 			？

**cinstexpr构造函数**

**7.6 类的静态成员**

类的静态成员存在于任何对象之外，类不含任何与静态数据成员有关的数据

静态成员函数也不与任何对象绑定在一起，不含this指针，不能声明成const的

成员函数不能通过作用域运算符就能直接使用静态成员

他们不是由构造函数初始化，通常不能在类内部初始化静态成员,

但可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr

```c++
class Account{
private:
	static constexpr int period = 30;	//period是常量表达式
}
```



12 **静态内存**:局部static对象，类static数据成员，定义在任何函数之外的变量

栈：定义在函数内非static对象，

**静态或栈内存中对象由编译器创建或销毁**，static对象使用前分配，结束时销毁，栈对象，仅在定义的程序块运行时才存在

堆或自由空间：存储动态分配的对象，程序运行时分配的对象，要显式的销毁

12.1 new:在动态内存中为对象分配空间，返回指向该对象的指针

内存泄漏：忘记释放内存

产生引用非法内存的指针：释放尚有指针引用的内存

weak_ptr:弱引用，指向shared_ptr管理的对象

12.1.1 默认初始化的智能指针中保存着一个空指针

```c++
shared_ptr<string> p;
*p = "hi"; //*p 解引用，将一个新值赋予string
*p  //解引用，获得它指向的对象
```

p.get() 

🔺shared_ptr<T>p(q) 会递增q中的计数器，q指针必须能转换成T*

p = q 递减p的引用计数，递增q的引用计数，p的计数为0，其管理的原内存会释放

p.unique()

p.use_count()

auto p = make_shared< vector< string >>();会进行**值初始化**，指向动态分配的空vector< string>

引用计数

**作为函数的返回值，引用计数会增加**

shared_ptr类通过析构函数完成销毁工作

**🔺shared_ptr 在无用之后任会保留的一种情况**：将 shared_ptr存放在一个容器中，随后重拍容器，从而不需要某些容器，需要确保earse那些不需要的shared_ptr元素      

使用了动态生成期的资源的类：1、程序不知道要使用多少对象：容器类

2、不知道所需对象的准确类型 

3、程序需要在多个对象间共享数据：**原对象和拷贝使用相同的底层元素**

**🔺12.1.2 自由空间分配的内存是无名的，所以**new无法为分配的对象命名**，返回一个指向该对象的指针

```c++
int *p = new int(10);	//直接初始化方式初始化一个动态分配的对象
string *p = new string(10, '9');	//传统的构造方式
vector<int> *p = new vector<int>{1,2,3...}  //列表初始化
```

也可以对动态分配的对象进行**值初始化**，后面跟一对空括号即可，

默认情况下是默认初始化的，类类型对象默认构造函数

```c++
string *p = new string; //默认初始化为空string
string *p = new string(); //值初始化为空string
```

**不管采用什么形式，对象都会通过默认构造函数来初始化，**

**对于内置类型，值初始化的内置类型对象有着良好定义的值，对于类中依赖于编译器合成的默认构造函数的内置类型成员，如果它们未在在类内被初始化，默认初始化的对象的值是未定义的**

**动态分配的const对象：**必须进行初始化，

对于定义了默认构造函数的类类型，其**const动态对象可以隐式初始化**，而其他类型的对象必须显示初始化		**？**

new返回的是指向const的指针

```c++
const string *p = new const string;
```

内存耗尽：bad_alloc、定位new、nothrow

```c++
int *p = new (nothrow) int;
```

delete p; p必须指向一个动态分配的对象或一个空指针，可以是一个const动态对象

**空悬指针：** 指向一块曾经保存数据对象，但现在已经无效的内存的指针(指针任然保留着已经释放了的动态内存的地址)，未初始化的指针的所有缺点空悬指针都有

**auto p = q; delete q; p和q均变为无效**

12.1.3 shared_ptr和new结合使用

🔺 **接受指针参数的智能指针的构造函数是explicit的，所以不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化的方式					？**

```c++
shared_ptr< int> p1 = new int(1024);   //错误

shared_ptr< int> p2(new int (1024));   //正确
```

**不能进行内置指针（普通指针）到智能指针之间的隐式转换**

一个返回shared_ptr的函数不能返回语句中隐式转换的一个普通指针

定义和改变shared_ptr的方法：shared_ptr< T> p(q)

```c++
return shared_ptr<int>(new int(p)); //显示的用int*创建shared_ptr<int>
```

p.reset()           **？**

**混合使用普通指针和智能指针的错误**：值传递、空悬指针、引用计数

```c++
void process(shared_ptr<int> ptr){ }
shared_ptr<int> p(new int(32));	//引用计数为1
process(p);	//拷贝p会怎加它的引用计数，在process中计数为2
int i = *p;	//引用计数为1

int *x(new int(32)); //x是一个普通指针，不是智能指针
process(x); //错误，不能将int*转换为一个shared_ptr<int>
process(shared_ptr<int>(x)); //合法，将一个临时的shared_ptr传递给process,内存会被释放
int j = *x; //x是一个空悬指针
```

**不要用get初始化另一个智能指针或者为另一个智能指针赋值**，各自的引用计数都是1

```c++
//get():向不能使用智能指针的代码传递一个内置指针，使用get返回的指针的代码不能delete此指针
shared_ptr<int> p(new int(21)); //引用计数为1
int *q = p.get(); //
{	//p q指向相同的内存，各自的引用计数都是1
    shared_ptr<int>(q);
} //程序块结束，q被销毁，指向的内存被释放
int foo = *p; //p指向的内存已经被释放
```

12.1.4 发生异常函数退出时，智能指针确保资源正确释放，直接管理的内存不会自动释放

**函数指针删除器**

```c++
void end_connection(connection *p){ disconect(*p); } //删除器函数
void f(destination &d)
{
    connection c = connect(&d);
    shared_ptr<connection> p(&c, end_connection);
    //使用连接，当f退出时(即使时由于异常退出)，connection会被正确关闭
    //当p被销毁时，它不会对自己保存的指针执行delete,而是调用end_connection()
}
```

**智能指针的陷阱：1、2、3、4、5**

1. 不使用相同的内置指针(或reset)初始化多个智能指针
2. 不delete get()返回的指针
3. 不使用get()初始化或reset另一个指针
4. 使用get()返回的指针，当最后一个对应的智能指针销毁后，指针就会变得无效
5. 使用智能指针管理的资源不是new分配的内存，需传递给它一个删除器

12.1.5 初始化unique_ptr必须采取**直接初始化的方式**

unique_ptr拥有它指向的对象，所以**不支持普通的拷贝或复制操作**

```c++
unique_ptr<string> p1(new string("string"));
unique_ptr<string> p2(p1); // × 不支持拷贝
p2 = p1; // × 不支持赋值
```

```c++
unique_ptr<T, D> u2                               ?
unique_ptr<T, D> u(d)
u = nullptr	     //释放u指向的对象，将u置空
u = realease()   //u放弃对指针的控制权，放回指针，将u置空
u = reset()      //释放u指向的对象
u.reset(q)		 //如果提供了内置指针q，令u指向这个对象，否则u置为空
```

🔺通过release和reset将指针所有权从一个（非const）unique_ptr转移给另一个unique

```c++
unique_ptr<string> p2(p1.release());  //将所有权从p1转移给p2,p1置空
unique_ptr<string> p3(new string("string")); 
p2.reset(p3.release());  //所有权从p3转移给p2,释放p2原来指向的内存
//release返回unique_ptr当前保存的指针并将其置空
//release返回的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值
p2.release()  // × p2不会释放内存，而且我们丢失了指针
auto p = p2.release() // √ 但必须记得delete p
```

**不能拷贝unique_str的例外**：可以拷贝或赋值一个将要被销毁的unique_str，例如从函数返回unique_str或局部对象的拷贝

```c++
unique_ptr<int> clone(int p)  
{
    return unique_ptr<int>(new int(p)); //从int*创建一个unique_ptr,从函数返回一个unique_ptr
	unique_ptr<int> ret(new int(p));
    return ret;  //返回局部对象的拷贝
}//编译器知道要返回的对象会被销毁，会执行一种特殊的“拷贝”
```

**向unique_str传递删除器           ？**

12.1.6 weak_ptr不控制指向对象生存期的指针，指向一个由shared_ptr管理的对象

```c++
weak_ptr<T> w
weak_ptr<T> w(sp) //与shared_ptr sp指向相同的对象的weak_ptr,T需能转换为sp指向的类型
w.reset()
w.use_count()
w.expired()
w.lock()  //如果expired为true,返回一个空shared_ptr,否则返回一个指向w的对象的weak_ptr
```

```c++
//创建weak_ptr时要用一个shared_ptr来初始化它
auto p = make_shared<int>(42);
weak_ptr<int> wp(p);
```

由于对象可能不存在，所以不能使用weak_ptr直接访问对象，必须调用lock检查weak_ptr指向的对象是否存在,如果存在返回指向共享对象的shared_ptr

```c++
if(shared_ptr<int> np = wp.lock()){ }
```

12.2 动态数组 new运算符

**new将内存分配和对象构造结合在一起，**

**delete将对象析构和内存释放结合在一起**

```c++
int *p = new int[size];
typedef int arr[size];
int *p = new arr;
```

new分配一个数组时，得到的**不是一个数组类型的对象，而是一个数组元素类型的指针**

不可以对动态数组调用begin和end，也不能用for语句处理动态数组中元素

```c++
//new分配的对象，都默认初始化，也可以对数组中元素值初始化
int *p = new int[size]; //10个未初始化的int
int *p = new int[size](); //10个值初始化为0的int
string *p = new string[10]; //10个空的string
string *p = new string[10] (); //10个空的string
//初始化器
int *p = new int[10]{1,2,3...}  //初始化器数目小于元素数目，剩余元素进行值初始化，如果大于，new表达式失败，抛出bad_array_new_length异常

char arr[0]; // ×，不能定义长度为0的数组
char *cp = new char[0];  // √ ，但cp不能解引用
```

bad_array_new_length异常

分配一个大小为0的数组时，new返回合法的非空指针，但**不能解引用** char *p = new char[0];

释放动态数组(释放一个指向数组的指针)：delete p[]; 数组中元素**按逆序销毁**

使用**类型别名**定义一个数组类型时，释放数组指针也要方括号 

智能指针和动态数组：unique_ptr< int[]> p(new int[]);

指向数组的unique_ptr不支持成员访问运算符，因为unique_ptr指向的是一个数组而不是单个对象，这些运算符无意义

```c++
unique_ptr<int []> p(new int[10]);
p.release();  //自动调用delete []销毁其指针
for(size_t i = 0; i != 10; i++)
    p[i] = i;  //unique_ptr指向一个数组时，可以用下标运算符访问元素
```

shared_ptr不直接支持动态数组，需要自定义删除器，否则直接delete的问题和没有[]一样

```c++
//为使用shared_ptr,需提供删除器
shared_ptr<int> p(new int[10], [](int *p) { delete[] p; });
p.reset(); 
```

shared_ptr没有定义下标运算，不支持指针的算术运算，为访问数组中元素必须用get获取内置指针，然后访问数组元素

```c++
for(size_t i = 0; i != 10; ++i)
    *(p.get() + i) = i; //使用get获取内置指针
```

12.2.2 allocator类

**🔺new 将内存分配和对象构造结合在一起，每个使用的元素都被赋值了两次，没有默认构造函数的类不能动态分配数组**

allocator 分配的内存是原始的未构造的，根据对象类型确定**内存大小和对齐位置**         **？**

a.construct(p, args) 初始化构造的对象

只能对真正构造了的元素进行destroy操作

alloc.deallocate(p,n);

allocator算法：uninitialized_copy()、uninitialized_fill()



13 

**拷贝构造函数，移动构造函数**：同类型的另一个对象初始化本对象时做什么

**拷贝赋值运算符，移动赋值运算符**: 将一个对象赋予同类型的另一个对象时做什么

析构函数：对象销毁时做什么

在定义任何c++类时，拷贝控制操作都是必要的

13.1.1 拷贝构造函数：

构造函数的**第一个参数是自身类型的引用，且任何额外参数都有默认值**，此构造函数就是拷贝构造函数，

拷贝构造函数会在几种情况下被隐式的使用，所以通常不是explicit的

```c++
class foo{
public:
    foo();  //默认构造函数
    foo(const foo&); //拷贝构造函数
}
//可以定义一个接受非const引用的拷贝构造函数
```

合成拷贝构造函数：

与合成默认构造函数不同，即使定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数

1. 对于某些类来说，合成拷贝构造函数用来阻止我们拷贝该类类型的对象
2. 一般情况，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中，编译器从给定的对象中依次将每个**非static**成员拷贝到正在创建的对象中
3. 每个成员的类型决定了它如何拷贝：类类型成员，使用拷贝构造函数拷贝；内置类型成员直接拷贝；不能直接拷贝一个数组，但合成拷贝构造函数会逐元素的拷贝一个数组类型的成员，数组元素是类类型，同上

直接初始化和拷贝初始化

```c++
// 差异：
string dots(10, '.');  //直接初始化,要求编译器使用普通的函数匹配
string s(dots);        //直接初始化
string s2 = s;		   //拷贝初始化，编译器将右侧运算对象拷贝到正在创建的对象中，如果需要，还要类型转换
string null_book = "99999"; //拷贝...
string nines = string(100, '9'); //拷贝...
```

🔺如果类有一个**移动构造函数**，拷贝初始化有时会依靠**移动构造函数**实现

🔺拷贝初始化发生情况：

1. 用=定义变量时
2. 将一个对象作为实参传递给一个非引用类型的实参 -> 解释了拷贝构造函数的参数必须是引用类型
3. 从一个返回类型为非引用类型的函数返回一个对象，返回值被用来初始化调用方的结果
4. 用花括号列表初始化一个数组中的元素或一个聚合类成员
5. 某些类类型会对它们所分配的对象使用拷贝初始化，如用初始化标准库容器或调用其insert或push成员时，容器会对其元素进行拷贝初始化，用emplace成员创建元素都是直接初始化

限制：explicit构造函数只能用于直接初始化

```c++
vector<int> v1(10);  // √ 直接初始化
vector<int> v2 = 10;  // × vector接受单一大小参数的构造函数是explicit的
void f(vector<int>);  // f的参数进行拷贝初始化
f(10);  // × 不能用一个explicit的构造函数拷贝一个实参
f(vector<int>(10)); // √ 从一个int直接构造一个临时的vector
// 传递一个实参或从函数返回一个值时，不能隐式的使用一个explicit构造函数
```

编译器可以绕过拷贝/移动构造函数，直接创建对象，但拷贝/移动构造函数必须时可访问的，不能是private

```c++
string null_book = "9999"; // 拷贝初始化
string null_book("9999"); //编译器忽略了拷贝构造函数
```

13.1.2 拷贝赋值运算符：如同类如何控制对象初始化，类也可以控制对象如何赋值

```c++
Sales_date trans, accum;
trans = accum; // 使用Sales_data的赋值运算符
//如果类未定义赋值运算符，编译器会为他合成一个
```

重载：赋值运算符就是一个 operator= 函数

赋值运算符必须定义为成员函数，那它**左侧运算对象就绑定到隐式的this参数**，其**右侧运算对象作为显示参数传递**

```c++
class foo{
public:
    foo& operator=(const foo&); // 返回指向左侧对象的引用,与内置类型的赋值保持一致
}
```

如果类未定义自己的拷贝赋值运算符，编译器会为他合成一个**合成拷贝赋值运算符**

某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值，

否则，拷贝赋值运算符会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，并**返回一个指向左侧运算对象的引用**

```c++
sales_data& 
sales_data::operator=(cosnt sales_data &rhs)
{
    bookno = rhs.bookno; // 调用string::operator=
    revenue = rhs.revenue;  // 使用内置int赋值
    return *this;  // 返回一个此对象的引用
}
```

13.1.3 析构函数：销毁对象的**非static**成员

**🔺析构函数自身不直接销毁成员，成员是在析构函数体之后的隐含的析构阶段中被销毁，在整个对象的销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分进行的**

没有返回值，不接受参数，因此不能被重载

函数体和析构体

**隐式销毁一个内置指针类型的成员不会delete它所指向的对象**

调用析构函数的情况：1、2、3、4、5

1. 变量离开它的作用域时被销毁
2. 一个对象被销毁时，其成员被销毁
3. 容器被销毁时，其元素被销毁
4. 动态分配的对象，当对指向它的指针应用delete运算符时被销毁
5. 临时对象，创建它的完整表达式结束时被销毁

```c++
{
	sales_data *p = new sales_data;
    auto p 
}
// 指向一个对象的引用或指针离开作用域时，析构函数不会执行
```

合成析构函数

某些类，合成析构函数**用来阻止该类型对象被销毁**，否则合成析构函数的函数体就为空

🔺合成析构函数不会delete一个指针数据成员

13.1.4 

需要**析构函数**的类，几乎也需要一个**拷贝构造函数**和一个**拷贝赋值运算符**

需要**拷贝构造函数**的类，几乎也需要一个**拷贝赋值运算符**，反之亦然

``` c++
class hasptr
{
public:
    hasptr(const std::string &s = std::string()) : ps(new std::string(s)), i(0) {}
    ~hasptr() { delete ps; }
}// × hasptr需要一个拷贝构造函数和一个拷贝赋值运算符
```

``` c++
// hasptr使用合成的拷贝构造函数和拷贝赋值运算符，这些函数简单拷贝指针成员，意味着多个hasptr对象可能指向相同的内存
hasptr f(hasptr hp) // hasptr是传值参数，所以将被拷贝
{
    hasptr ret = hp;  // 拷贝给定的hasptr
    return ret; // ret 和 hp被销毁
} // f 返回时，ret和hp都被销毁，在两个对象上调用析构函数，但这两个对象包含相同的指针值，该指针被delete两次

hasptr p("some values");
f(p); // f结束时，p.ps指向的内存被释放
hasptr q(p); // p和q都指向无效内存
```

13.1.5 =default ：显示的要求编译器生成合成的版本，

🔺在**类内**用=default修饰成员的声明时，合成的函数将**隐式的声明为内联的**

在类外定义使用=defalult时，不是内联的

13.1.6 阻止拷贝或赋值

例如，iostream类阻止了拷贝，以避免多个对象写入或读取像相同的io缓冲，为阻止拷贝，不定义拷贝控制成员是无效的，因为编译器会生成合成的版本

**定义删除的函数 =delete 来阻止拷贝**，声明了它们，但不能以任何方式使用他们

``` c++
struct nocopy{
    nocopy() = delete;
    nocopy(const nocopy&) = default;
    nocopy& operator=(const nocopy&) = default;
    !nocopy() = delete;
}
```

和 = default的不同:1，2

1. =delete必须出现在函数第一次声明的时候，=default直到编译器生成代码时才需要
2. 可以对任何函数指定=delete，只能对编译器可以合成的默认构造函数和拷贝控制成员使用=default

**🔺析构函数不能是删除的成员**，否则就无法销毁此类型的对象了，一个删除了析构函数的对象，编译器不允许定义该类型的变量或创建该类型临时对象，可以动态分配这种类型的对象，但不能释放这些对象

```c++
struct nodtor{
    nodtor() = default;
    ~nodtor() = delete;
}
nodtor nd; // ×
nodtor *p = new nodtor(); // √ 但不能delete
delete p; // ×
```

**🔺合成的拷贝控制成员可能是删除的：对于某些类编译器将合成的成员(拷贝控制，默认构造)定义为删除的函数 1，2，3，4，5**

1. 如果类的某个成员的**析构函数**是删除的或不可访问的(如private)，则类的合成析构函数被定义为删除的

2. 如果类的某个成员的**拷贝构造函数**是删除的或不可访问的，则类到合成拷贝构造函数被定义为删除的

   如果类的某个成员的**析构函数**是删除的或不可访问的，则类**合成的拷贝构造函数**也被定义为删除的

3. 如果类的某个成员的**拷贝赋值运算符**是删除的或不可访问的，或**类有一个const的或引用成员**，则类合成的拷贝赋值运算符被定义为删除的

4. 如果类到某个成员的析构函数是删除的或不可访问的，或是**类有一个引用成员**，它没有类内初始器，或是**类有一个const成员**，它没有类内初始器且其类型未显示定义默认构造函数，则该类的**默认构造函数**被定义为删除的                                 **？**

本质上，如果一个类有数据成员不能默认构造、拷贝、复制、销毁则对应的成员函数将被定义为删除的

**析构函数如果是private的，则不能定义该类型的对象**

private:将拷贝构造函数和拷贝赋值运算符声明为private的来阻止拷贝，用户不能拷贝这个类型的对象，

**但友元和成员函数仍可以拷贝对象，**

为阻止友元和成员拷贝，可以将这些拷贝控制声明为private的，但不定义它们，试图访问一个位定义的成员将导致链接时错误，这样试图拷贝对象的用户代码将在编译阶段被标记为错误，友元和成员函数的拷贝操作会导致链接时错误

**声明但不定义一个成员函数是合法的，对此只有一个例外**

13.2 确定类型对象的拷贝语义：可以定义拷贝操作，使类的行为看起来像**一个值或一个指针**

像值：类有自己的状态，拷贝一个对象时，副本和原对象**完全独立**，改变副本不会对原对象有影响，如标准库容器和string类

像指针：**共享状态**，拷贝一个这种类的对象时，副本和原对象有**相同的底层数据**，改变副本会改变原对象，如shared_ptr类

不允许拷贝和赋值两者都不像：如IO类型和unique_ptr不允许拷贝和赋值

13.2.1 行为像值的类：每个对象都有一份自己的拷贝

实现类的行为需要：

1. 定义一个拷贝构造函数，完成string的拷贝，而不是拷贝指针
2. 定义一个析构函数释放string
3. 定义一个拷贝赋值运算符释放对象当前的string，并从右侧运算对象拷贝string

```c++
class hasptr{
public:
    
}
hasptr& hasptr::operator=(const hasptr &rhs)
{
    
}
```

类值的拷贝赋值运算符：

1. 赋值操作会销毁左侧运算对象的资源
2. 赋值操作从右侧运算对象拷贝数据
3. 上面两个操作是以正确顺序执行，即使一个对象赋予它自身也保证正确
4. 异常安全的：异常发生时可以将左侧对象置于一个有意义的状态

```c++
// 先拷贝右侧运算对象，处理自赋值情况，并保证异常发生时代码也安全，完成拷贝后，释放左侧运算对象的资源，更新指针指向新的string
hasptr& hasptr::operator=(const hasptr &rhs)
{
    auto newp = new string(*rhs.os); // 拷贝底层string(拷贝构造函数)
    delete ps;  // 释放就内存(析构函数)
    ps = newp;  //从右侧运算对象拷贝数据到本对象
    i = rhs.i;
    return *this; // 返回本对象
}
// 大多数赋值运算符组合了析构函数和拷贝构造函数的工作
```

行为像指针的类：拷贝指针成员本身而不是它指向的string，析构函数不能单方面的释放关联的string，自由当最后一个指向string的对象销毁时，才可以释放string,可以使用shared_ptr来管理类中的资源

引用计数：不使用shared_ptr,直接管理资源

1. 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器，如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户了，拷贝赋值运算符必须销毁状态
2. 计数器不能直接作为hasptr对象的成员 -->  将计数器保存到**动态内存**中，创建一个对象时分配一个新的计数器，拷贝或赋值对象时，拷贝指向计数器的指针，这样副本和原对象都会指向相同的计数器

```c++
class hasptr{
public:
    
}
hasptr::~hasptr()
{
    
}
hasptr& hasptr::operator=(cosnt hasptr &rhs)
{
    
}
```

13.3 交换操作

```c++
// 一次拷贝，两次赋值
hasptr temp = v1;
v1 = v2;
v2 = temp;

//  交换指针，不分配string新副本，避免内存分配
string *temp = v1.ps; //为v1中指针创建副本
v1.ps = v2.ps;
v2.ps = temp；
```

```c++
class hasptr{
    friend void swap(hasptr&, hsptr&);
}
inline void swap(hasptr& lhs, hasptr& rhs)
{
    using std::swap; // 如果存在类型特定的swap版本，swap调用会与之匹配，否则使用std版本
    swap(lhs.ps, rhs.ps); //交换指针，而不是string数据
    swap(lhs.i, rhs.i);
}
```

swap 和 std::swap

值传递+swap = 赋值运算符

```c++
hasptr& hasptr::operator=(hasptr rhs) // 按值传递，rhs是右侧运算对象的一个副本
{
    swap(*this, rhs); // 交换左侧运算对象和局部变量rhs内容，现在rhs指向本对象曾经使用的内存
    return *this; // rhs被销毁，从而delete了rhs中的指针
}
// 这是异常安全的，且能处理自赋值，唯一可能抛出异常的是拷贝构造函数中的new表达式，如果发生异常，会在改变左侧运算对象之前发生
```

🔺13.5 自己设计一个动态内存管理类

allocator 分配未构造的原始内存

**移动构造函数** --> 避免sring的拷贝，进行指针的拷贝而不是为字符分配空间然后拷贝字符

**std::move** --> 调用move表示希望使用string的移动构造函数，否则使用拷贝构造函数，不为move提供using声明，直接调用 std::move而不是move

13.6 对象移动：

1. 在重新分配内存的过程中，从旧内存及那个元素拷贝到新内存是不必要的
2. 类似IO类或shared_ptr这样的类，包含不能被共享的资源(IO缓冲或指针)，不能拷贝但可以移动

标准库容器、string和shared_ptr类既支持移动也支持拷贝，IO和shared_ptr只支持移动但不可以拷贝

可以移动而非拷贝对象的能力

13.6.1 右值引用 ：必须绑定到右值的引用，通过&&而不是&来获得右值引用，一个重要性质--只能绑定到**一个将要销毁的对象**，因此可以自由的将一个右值引用的资源移动到另一个对象中

左值表达式表示的是一个对象的身份，右值表达式表示的是对象的值

**常规引用(左值引用)**：不能将其绑定到要求转换的**表达式、字面常量、返回右值的表达式**

右值引用：可以绑定到这类表达式上，但不可以绑定到左值上

```c++
int i = 32;
int &r = i; // √ r引用i
int &&rr = i;  // × 不能将一个右值引用绑定到一个左值上
int &r2 = i * 32; // × i*32是一个右值
const int &r3 = i * 32; // √ 可以将一个const引用绑定到右值上
int &&rr2 = i * 43; // √ 将rr2绑定到乘法结果上
// 返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值表达式，可以绑定左值引用
// 返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值，不可以将左值引用绑定到这类表达式上，但可以绑定一个const的左值引用或右值引用
```

左值有持久的状态；右值短暂，要么是字面常量，要么是表达式求值过程中创建的临时变量，由于右值引用只能绑定到临时对象：

1. 所引用的对象将要被销毁 2.该对象没有其他用户 --> 右值引用的代码可以自由的接管所引用的对象的资源

**变量是左值**：变量可以看作只有一个运算对象没有运算符的表达式，**变量表达式都是左值**，不能将一个右值引用绑定到一个右值引用类型的变量上

```c++
int &&rr1 = 43; // √ 字面值常量是右值
int &&rr2 = rr1; // × 表达式rr1是左值，右值表示临时对象，而变量rr1是持久的
```

🔺标准库move函数：**告诉编译器我们有一个左值，但希望像一个右值一样处理它**

1. **不可以将右值引用直接绑定到一个左值上，但可以显示的将一个左值转换为对应的右值引用类型**
2. 通过调用move函数获得绑定到左值上的右值引用
3. move函数返回给定对象的**右值引用**

```c++
int &&rr3 = std::move(rr1); // √
// 调用move意味着承诺：除了对rr1赋值或销毁它外，不再使用它(不能使用一个移后源对象的值)
// 对move不提供using声明，直接调用std::move而不是move
```

13.5.2 移动构造函数和移动赋值运算符

**移动构造函数**：第一个参数是该类类型的一个引用，不同于拷贝构造函数，这个引用参数是一个**右值引用**，任何额外的参数都必须有默认实参

```c++
strvec::strvec(strvec &&s) noexcept // 移动操作不应抛出任何异常
    : elements(s.elements), first_free(s.first_free), cap(s.cap) // 成员初始化接管s中的资源
    {
        s.elements = s.first_free = s.cap;
    }
//和拷贝构造函数不同，移动构造函数不分配任何新内存；接管给定的strvec中的内存，接管内存后，将给定对象中的指针都置为nullptr，这样完成移动操作后，此对象将继续存在                   ？
// 最终移动对象将被销毁，以为这在其上运行析构函数，strvec的析构函数会在first_free上调用deallocate,如果忘记改变s.first_free,则销毁移后源对象就会释放掉我们刚刚移动的内存            ？
```

不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept

**移动赋值运算符**：执行与析构函数和移动构造函数相同的工作

```c++
strvec& strvec::operator=(strvec &&rhs) noexcept
{
    if(this != rhs)  // 检查自赋值
    {
        free();  //释放已有元素
        elements = rhs.elements;  // 从rhs接管资源
        first_free = rhs.first_free;
        cap = rhs.cap;
        // 将rhs置于可析构的状态
        rhs.elements = rhs.first_free = rhs.cap = nuLLptr;
    }
    return *this;
}

// 如果右侧和左侧运算对象指向不同的对象，则释放左侧运算对象使用的内存，接管给定对象的内存
// 移动赋值运算符需要右侧运算对象是一个右值，但任然需要检查字赋值，因为右侧可能是move调用返回的结果
// 不能在使用右侧运算对象的资源之前就释放左侧运算对象的资源(可能有相同的资源)
```

移后源对象必须保持有效的、可析构的状态：

1. 从一个对象移动数据并不会销毁此对象，但有时移动操作完成后，源对象会被销毁，必须确保移动后源对象进入一个可析构的状态，strvec中通过将源对象指针成员设为nullptr实现
2. 移动操作还必须保证对象仍然有效，指可以安全的为其赋值或安全的使用而不依赖当前值
3. 移动操作对移后源对象中留下的值没有任何要求，程序不应该依赖移后源对象中的数据

**合成的移动操作：**

合成拷贝操作要么被定义为逐成员拷贝、要么被定义为对象赋值、要么被定义为删除的函数

1. **如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符**
2. 如果一个类没有移动操作，通过正常的函数匹配，类会使用对应的拷贝操作来代替移动操作
3. 只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static成员都可以移动，编译器才会为它合成移动构造函数和移动赋值运算符，编译器可以移动内置类型的成员和有对应移动操作的类类型

```c++
// 编译器会为 X和hasX合成移动操作
struct X{
    int i; // 内置类型可以移动
    std::string s;  // string有移动操作
};
struct hasX{
    X mem;  // X有移动操作
}
X x, x2 = std::move(x);  //使用合成的移动构造函数
haxX hx, hx2 = std::move(hx);  //使用合成的移动构造函数
```

移动操作永远**不会隐式定义为删除的函数**，但是如果我们显示的要求编译器生成=default的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的

🔺将合成的移动操作定义成删除的函数遵循的原则：       **？**

1. 与拷贝构造函数不同，移动构造函数定义成删除函数的条件是：有类成员定义了自己的**拷贝构造函数**且未定义**移动构造函数**，或者是有类成员定义了自己的**拷贝构造函数**且编译器不能为其**合成移动构造函数**。移动赋值运算符类似
2. 如果有类成员的移动构造函数或移动赋值运算符定义为**删除的或不可访问的**，则类的移动构造函数或移动赋值运算符定义为删除的
3. 类似拷贝构造函数，如果类的析构函数被定义为**删除的或不可访问的**，则类的移动构造函数定义为删除的
4. 类似拷贝赋值运算符，如果类成员是**const的或是引用的**，则类的移动赋值运算符被定义为删除的

```c++
// 假定y是一个类，定义了自己的拷贝构造函数，未定义自己的移动构造函数
struct hasy{
    hasy() = default;
    hasy(hasy&&) = default;
    y mem; // hasy将有一个删除的移动构造函数
}
hasy hy, hy2 = std::move(hy); // × 移动构造函数是删除的
// 编译器可以拷贝类型未y的对象，但不能移动它们
// 类hasy显示的要求一个移动构造函数，但编译器无法为器生成，因此hasy会有一个删除的移动构造函数
// 如果haxy忽略了移动构造函数的声明，则编译器根本不能为它合成一个   ？
// 如果移动操作肯被定义为删除的函数，编译就不会合成它们      ？
```

🔺移动操作和合成的拷贝控制成员之间的一个相互关系：如果类定义了一个**移动构造函数和/或一个移动赋值运算符**，则该类的**合成拷贝构造函数**和**拷贝赋值运算符**会被定义为**删除的**，（定义了一个移动构造函数移动赋值运算符的类必须定义自己的拷贝操作，否则，这些成员默认的被定义为删除的）

**移动右值，拷贝左值...**

如果一个类既有拷贝构造函数，又有移动构造函数，编译器使用普通的函数匹配规则确定使用哪一个构造函数：

```c++
// strvec类中，拷贝构造函数接受一个const strvec引用，因此可以用于任何转换为strvec的类型
// 而移动构造函数接受一个strvec &&，因此只能用于实参是(非static)右值的情形
strvec v1,v2;
v1 = v2;  // v2是左值，使用拷贝赋值
// v2是一个左值，不能隐式的将一个右值引用绑定到一个左值，因此赋值语句使用拷贝赋值

strvec getvec(istream &);  // getvec返回一个右值
v2 = getvec(cin); // getvec(cin)是一个右值，使用移动赋值
// 赋予v2的是getvec的调用结果，此表达式是一个右值，此情况下，将getvec的结果绑定到两个运算符的参数是允许的，两个赋值运算符都可行
// 调用拷贝赋值运算符，需要一次const转换，
// strvec &&是精确匹配，因此使用移动赋值运算符
```

**...如果没有移动构造函数，右值也被拷贝**(对象通过拷贝构造函数移动)

类有一个拷贝构造函数，但未定义移动构造函数 --> 编译器不会合成移动构造函数 --> 类有拷贝构造函数但没有移动构造函数 --> 函数匹配规则保证该类型的对象会被拷贝，即使通过move来移动也是如此：

```c++
class foo{
public:
    foo() = default;
    foo(const foo&);  // 拷贝构造函数，但没定义移动构造函数
};
foo x;
foo y(x); // 拷贝构造函数，x是一个左值
foo z(std::move(x)); // 拷贝构造函数，因为未定义移动构造函数
🔺// 对z进行初始化时，move(x)返回一个绑定到x的foo &&,foo拷贝构造函数是可行的，因为可以将foo &&转换未const foo&
```

用拷贝构造函数代替移动构造函数是安全的：会拷贝给定对象，并将原对象置于有效状态

**拷贝并交换赋值赋值运算符：**

```c++
public:
    hasptr(hasptr &&p) noexcept : ps(p.ps), i(p.i){
        p.ps = 0; // 确保销毁移动源后对象是安全的
    }
    hasptr& operatpr=(hasptr rhs){ // 非引用实参
        swap(*this, rhs);
        return *this;
    } // 既是移动赋值运算符，也是拷贝赋值运算符
}
// 赋值运算符，非引用实参意味着这个参数要进行拷贝初始化，根据实参类型，左值被拷贝使用拷贝构造函数，右值被移动使用移动构造函数

hp = hp2; //拷贝
hp = std::move(hp2); // 移动
```

移动迭代器：解引用运算符生成一个右值引用

make_move_iterator:将普通迭代器转换为移动迭代器

13.6 右值引用和成员函数

引用限定符



15 OOP

15.1 类派生列表

1. 派生类必须在其内部对所有**重新定义的虚函数进行声明**，派生类可以在这样的函数之前加上virtual
2. 派生类可以显式的注明它将使用**哪个成员函数改写基类的虚函数**，通过在该函数的形参列表之后加override

```c++
class quote{
public:
    std::string isbn() const;
    virtual double net_price(std::size_t n) const;
}
class bulk_quote : public quote{
public:
    double net_price(std::size_t n) cosnt override;
}
```

动态绑定:用同一段代码分别处理quote和bulk_quote对象

运行时绑定：函数的运行版本由实参决定

**🔺使用基类的引用(或指针)调用一个虚函数时会发生动态绑定**

```c++
double print_total(ostream &os, const quote& item, size_t n)
{
    double ret = item.net_price(n);
    os << item.isbn() << endl;
    return ret;
}
// 因为函数print_total的item形参是基类的一个引用，所以既能使用quote的对象调用该函数也能使用派生类bulk_quote的对象调用它、
// 因为print_total使用引用类型调用net_price,所以实际传入print_total的对象类型决定执行net_price的哪个版本
print_total(cout, basic, 20);
print_total(cout, bulk, 20);
```

基类通常应该定义一个虚析构函数：

```c++
class quote{
public:
    virtual ~quote() = default;  // 对析构函数进行动态绑定
    ...
}
```

覆盖(override)：

1. 派生类可以继承基类的成员，当遇到如net_price这样与类型相关的操作时，派生类必须对其进行重新定义，即提供新定义来覆盖从基类继承来的定义
2. 使用引用(或指针)调用一个虚函数时，该调用被动态绑定，给句引用或指针绑定的对象类型，决定调用基类或是派生类的版本
3. **🔺任何构造函数之外的非静态函数都可以时虚函数**：关键字virtual只能出现在**类内部**的声明语句之前而**不能用于类外部**的函数定义，如果基类把一个函数声明成虚函数，则该**函数在派生类中隐式的也是虚函数**
4. 如果函数不是虚函数，则其解析过程**发生在编译时而不是运行时**
5. 派生类可以访问**公有成员**而不能访问**私有成员**
6. protected:派生类有权访问，而其他用户不能访问的成员

```c++
class quote{
protected:
	double price = 0.0;
}
```

15.2.2 

能将公有派生类型的对象绑定到基类的引用或指针上

派生类中的虚函数：

1. 如果派生类没有覆盖其基类中的某个虚函数，派生类会直接继承其在基类中的版本
2. 派生类可以在覆盖的虚函数之前使用virtual,或显示的注明它使用某个成员函数覆盖了它继承的虚函数，通过override关键字

派生类到基类的类型转换：

1. 派生类对象含有多个组成部分：自己定义的(非静态)成员的子对象，继承的基类的子对象
2. c++没有明确规定派生类的对象在内存中如何分布，基类的部分和子定义的部分**不一定连续存储**
3. 可以将派生类对象当初基类对象使用，可以将基类的**指针或引用**绑定到派生类的基类部分上
4. 也可以把派生类的对象的**指针**用在需要基类指针的地方

```c++
quote item;
bulk_quote bulk;
quote *p = &item;
p = &bulk;   // p指向bulk的quote部分
quote &r = bulk;  // r绑定到bulk的quote部分
```

派生类构造函数：

1. 尽管派生类含有从基类继承来的成员，但派生类**不能直接初始化这些成员**，必须使用基类的构造函数来初始化它的基类部分
2. 派生类同样通过构造函数初始化列表将实参传递给基类构造函数

```c++
bulk_quote(const std::strng &book, double p, std::size_t qty, double disc) :
	quote(book, p), min_qty(qty), discount(disc) { } 
//  先由quote的构造函数初始化bulk_quote的基类部分
//  再执行quote空的构造函数体
//  再初始化派生类直接定义的成员
//  再执行bulk_quote空的构造函数体
```

继承与静态成员：

1. 每个静态成员只存在唯一的实例
2. 静态成员遵循访问控制原则，如果是private的，则派生类无权访问它

基类：

1. 将某个类用作基类，必须已经**定义而非仅仅声明**，派生类要使用基类继承而来的成员必须要指定它们是什么-->**一个类不能派生它本身**
2. 直接基类，间接基类
3. final:使类不能作为基类

```c++
class noderived final { ... } // 不能作为基类
```

15.2.3  **类型转换**

将引用或指针绑定到一个对象上的条件：

1. 引用或指针的类型与对象一致
2. 对象的类型含有一个可接受的const类型转换规则
3. 基类指针或引用可以绑定到派生类对象上

**🔺静态类型**：在编译时总是已知的，是变量声明时的类型或表达式生成的类型                 **?**

**动态类型**：变量或表达式表示的内存中对象的类型，直到运行时才知

1. 如果表达式既不是指针也不是引用，则动态类型永远和静态类型一直
2. 基类的指针或引用的静态类型可能与其动态类型不一致

**不存在基类向派生类的隐式类型转换...**

1. 如果合法，可能访问根本不存在的成员
2. 即使基类引用或指针绑定在一个派生类对象上，也不能执行从基类向派生类的转换

```c++
quote base;
bulk_quote *p = &base; //  ×
bulk_quote &q = base; // ×

bulk_quote bulk;
quote *iotm = &bulk;  // 动态类型是bulk_quote
bulk_quote *bulkp = item;  // ×
```

1. 编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或引用的**静态类型**来推断是否合法                                               **？**
2. 如果基类中含有一个或多个虚函数，可以使用**dynamic_cast**请求一个类型转换，该转换的安全检查将在**运行时执行**
3. 如果已知某个基类向派生类的转换是安全的，可以使用**static_cast强制覆盖**掉编译器的检查工作

**...在对象之间不存在类型转换**

1. 自动类型转换只在引用和指针之间有效，在**派生类类型和基类类型之间不存在转换**
2. 初始化或赋值一个对象时，实际是在调用某个函数，如构造函数、赋值运算符等，这些成员通常都包含一个参数，该参数的类型是类类型的const版本的引用 --> 这些成员接受引用作为参数，所以派生类向基类的转换允许给基类的拷贝/移动操作传递一个派生类对象，这些操作**不是虚函数** -->  实际运行的构造函数是基类中定义的那一个，只能处理基类自己的成员 -->  **切掉**

```c++
bulk_quote bulk;  // 派生类对象
quote item(bulk);  // 使用quote::quote(const quote&)构造函数
item = bulk;  // 调用quote::operator=(const quote&)
```

15.3 虚函数 ：**引用或指针的静态类型和动态类型不同正是多态性的根本所在**

1. **动态绑定只有通过指针或引用调用虚函数时才会发生**
2. 使用基类的引用或指针调用一个虚成员函数时会执行动态绑定 --> 直到运行时才知道到底调用了哪个版本的虚函数 --> 所以的虚函数都必须有定义
3. 对虚函数的调用可能在运行时才被解析：被调用的函数是与绑定到指针和引用上的对象的**动态类型**相匹配的那一个
4. 通过一个具有普通类型(非引用非指针)的表达式调用虚函数时，在编译时会将版本确定下来

派生类中虚函数：

1. 派生类如果覆盖了继承而来的虚函数，**形参类型**必须与它覆盖的基类函数完全一致
2. 派生类中虚函数的**返回类型**也必须与基类函数一致，例外：如果虚函数返回类型是**类本身的指针或引用**，则规则无效

override：

1. 派生类如果定义了一个函数与基类中虚函数的名字相同但形参列表不同，仍然合法，但两个函数相互独立，没有覆盖
2. 使用override说明派生类中的虚函数，避免1中情况的出现
3. **只有虚函数才能被覆盖**
4. 将函数指定为final,之后的覆盖会发生错误

```c++
struct B{
    
};
struct A : B {
    
};
```

虚函数与默认实参：

1. 虚函数也有默认实参，如果某次函数调用使用了默认实参，则实参值由本次调用的**静态类型**决定 --> 如果通过基类的指针或引用调用函数，则使用基类中定义的默认实参，即使运行的是派生类中的函数版本
2. 基类和派生类中的虚函数的默认实参最好一致

回避虚函数的机制：希望对虚函数的调用不进行动态绑定，强迫执行某个特定版本，使用域运算符 

```c++
double undiscounted = baseP->quote::net_price(32);  // 该调用将在编译时完成解析
```

通常只有成员函数(或友元)中代码才需要回避虚函数机制 

**如果一个派生类虚函数需要调用它的基类版本，但没有用作用域运算符，则在运行时该调用将被解析位对派生类自身调用，导致无限递归**

15.4 抽象基类：含有纯虚函数的类

纯虚函数：=0

1. 将函数定义成纯虚的，告诉用户当前这个函数没有任何意义
2. 和普通函数不同，纯虚函数无需定义
3. =0 只能出现在类内部的虚函数的声明处
4. 可以为纯虚函数提供定义，但必须定义在类的外部

含有(或未经覆盖直接继承)纯虚函数的类是抽象基类：

1. 不可以直接创建一个抽象基类的对象
2. 可以定义抽象基类的派生类的对象，前提是派生类覆盖了纯虚函数
3. 派生类必须给出自己的继承的纯虚函数的定义，否则它仍然是抽象基类

派生类构造函数只能初始化它的直接基类：

每个类各自控制其对象的初始化过程，即使bulk_quote没有自己的数据成员，它也仍然需要向原来一样提供一个**接受四个参数的构造函数**，将它的实参传递给disc_quote的构造函数

**重构**

15.5 访问控制和继承

protected:受保护的

1.  对类的用户来说不可访问
2. 对派生类的成员和友元不可访问
3. 派生类的成员和友元只能通过**派生类对象**来访问**基类(派生类对象中基类部分)的受保护成员**，派生类对一个基类对象的受保护成员没有任何访问特权

```c++
class base{
protected:
    int prot_mem;
};
class sneaky : public base {
    friend void clobber(sneaky &); //可以访问sneaky::prot_mem
    friend void clobber(base &);  // 不能访问base::prot_mem,否则可以通过形如sneaky的类，简单的规避掉protected提供的访问保护
    int j; //默认是private
}
```

🔺某个类对其继承而来的成员的访问权限受两个影响：

1. 基类中该成员的访问说明符
2. 在派生类的派生列表中的访问说明符(派生访问说明符)

派生类向基类转换的可访问性：D：B

1. 只有D**公有**的继承B时，用户代码才能使用派生类向基类的**转换**；如果是**受保护的或私有**的，**无法使用该转换**
2. 无论什么继承方式，D的**成员函数和友元**都可以使用派生类向基类的转换；派生类向**直接基类**的类型转换对派生类成员和友元来说永远是可访问的
3. 如果D的继承方式是**公有的或受保护的**，则D的**派生类的成员和友元**都可以使D向B类型转换；反之，如果D继承B的方式是私有的，则不可以

友元和继承：

1. 友元关系不能传递
2. 友元关系不能继承，基类的友元在访问派生类的成员时不具有特殊性，同样派生类的友元不能随意访问基类的成员
3. 每个类赋值控制各自成员的访问权限

```c++
class base {
    friend class pal;
protected:
    int prot_mem;
};

class sneaky : public base {
    int j; //默认是private
};

class pal {
public:
    int f(base b) { return b.prot_name; } // √ pal是base的友元
    int f2(sneaky s) { return s.j; } // × pal不是sneaky的友元
   //对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此
    int f3(sneaky s) { return s.prot_name; } // √ pal是base的友元，可以访问base对象的成员，这种可访问性包括了base对象内嵌在其派生类对象中的情况
};

class D : public pal {
public:
    int mem(base b) { return b.prot_mem; } // × 友元关系不能继承
};
```

改变个别成员的可访问性：通过using声明改变派生类继承的某个名字的访问级别

```c++
class base {
public:
    std::size_t size() const { return n; }
protected:
    std::size_t n;
};

class derived : private base {   // 私有继承
public:
    // using保持对象尺寸相关的成员的访问级别
    using base::size;
protected:
    using base::n;
};
```

1. 私有继承而来的成员size和n默认是derived的私有成员
2. 使用using改变了size和n的可访问性，改变之后，devried的**用户**将可以使用size，devried的派生类可以使用n
3. 在类内使用using声明可以将该类的**直接或间接基类**中任何**可访问成员**(如非私有成员)标记出来，
4. using声明语句中的名字的访问权限由该using语句之前的访问说明符决定：using出现在private部分，该名字只能被**类成员和友元**访问；using出现在protected部分，该名字只能被**类成员、友元、派生类**访问；using出现在public部分， 所以用户都可以访问
5. **派生类**只能为那些它**可以访问**的名字提供using声明

stuct和class：

1. class定义的派生类是私有继承，struct定义的派生类是公有继承
2. 唯一的区别就是默认成员访问说明符和**默认派生访问说明符**

```c++
class base { .. };
struct D1 : base { ... }; // 默认public继承
class D2 : base { ... }; // 默认private继承
```

15.6 继承中的类的作用域

派生类的作用域嵌套在其基类的作用域中

**🔺一个对象、引用或指针的静态类型决定了该对象哪些成员可见，即使静态类型与动态类型不一致(使用基类的引用或指针时会发生)，能使用哪些成员仍然由静态类型决定**											**?** 

```c++
 
```

隐藏的成员：

1. 派生类的成员会隐藏同名的基类成员
2. 通过作用域运算符使用隐藏的成员
3. 定义在派生类中的成员**不会重载**其基类中的成员，即使派生类成员和基类成员的**参数列表不一致**，**基类成员也会被隐藏掉**( 名字查找先于类型查找): 编译器会在派生类中查找名字相同的函数，如果名字相同参数不同，就不再继续查找而是直接报错

🔺虚函数和作用域：                         **?**

1. 如果基类和派生类的虚函数接受的实参不同，无法通过基类的引用或指针调用派生类的虚函数 --> **基类和派生类中虚函数必须要有相同的形参列表**

```c++
class base {
public:
    virtual int fun();
};

class D1 : public base {
public:
    int fun(int);
    virtual void f2();
};

class D2 : public D1 {
public:
    int fun(int);   // 非虚函数，隐藏了D1::fun(int)
    int fun();    // 覆盖了base的fun()
    void f2();
}

base b; D1 d1; D2 d2;
base *b1 = &b, *b2 = &d1, *b3 = &d2;
b1->fun();
b2->fun();
b3->fun();

D2 *p1 = &d1, *p2 = &d2;
b2->f2();
p1->f2();
p2->f2();

base *a1 = &d2; D1 *a2 = &d2; D2 *a3 = &d2;
a1->fun(21);
a2->fun(21);
a3->fun(21);
```

**成员函数无论是不是虚函数都能被重载**:

1. 派生类可以覆盖重载函数的0个或多个实例
2. 覆盖基类中的每一个版本：为重载的成员提供一条using声明语句，指定一个名字而不是形参列表，所以**一条基类成员函数的using声明语句就可以把该函数的所以重载实例添加到派生类的作用域中**            **？**

15.7.1 虚析构函数

🔺继承关系对基类拷贝控制最直接的影响是**基类通常应该定义一个虚析构函数**，这样就能**动态分配继承体系中的对象**(如果我们删除一个指向派生类对象的基类指针，就需要虚析构函数)

1. delete一个动态分配的对象的指针将执行析构函数 --> 指针的静态类型和动态类型可能不一致 --> 编译器需要知道执行哪一个析构函数 --> 将基类中析构函数定义成虚的确保执行正确的析构函数版本，否则会产生未定义的行为
2. 析构函数的虚属性会被继承，无论quote的派生类使用合成的析构函数还是自己定义的析构函数，**都是虚的**
3. 如果一个类需要析构函数，则它同样需要拷贝和赋值操作，例外：**基类的虚析构函数不用遵循**，因为析构函数为了成为虚函数令内容为空，则无法推断该基类还需要赋值运算符或拷贝构造函数
4. **虚析构函数将阻止合成移动操作**，即使通过=default形式使用了合成的版本，也不会为类合成移动操作

```c++
class quote {
public:
    virtual ~quote() = default; // 动态绑定析构函数
}

quote *item = new quote; // 静态类型和动态类型一致
delete item; // 调用quote的析构函数
item = new bulk_quote; // 静态类型和动态类型不一致
delete item; //  调用bulk_quote的析构函数
```

15.7.2 合成拷贝控制和继承



所有类都使用合成的析构函数，派生类隐式的使用，基类通过=default显示的使用

**派生类中删除的拷贝控制与基类的关系**（是被删除的或者不可访问的）

15.7.3 派生类的拷贝控制成员

1. 派生类构造函数在初始化阶段不但需要初始化派生类自己的成员，还有派生类对象的基类部分
2. 派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员
3. 派生类赋值运算符也必须为基类部分成员赋值
4. **析构函数只负责销毁派生类自己分配的资源**，对象的成员是被隐式销毁的，基类部分的也是自动销毁的

**定义派生类的拷贝或移动构造函数**：通常使用**对应的基类构造函数**初始化对象的基类部分 (如果想拷贝和移动基类部分，必须在派生类的构造函数中显示的使用基类的拷贝或移动构造函数)

```c++
class base { ... };
class D : public base {
public:
    // 默认情况下，基类的默认构造函数初始化对象的基类部分
    // 要想使用拷贝或移动构造函数，必须在构造函数初始化列表中显示的调用该构造函数
    D(const D& d) : base(d) // 拷贝基类成员
    	{ ... } // base(d)会匹配base的拷贝构造函数,D类型对象d会被绑定到该构造函数的base&形参上
    D(D&& d) : base(std::move(d)) // 移动基类成员
    	{ ... }
    
    D(const D& d) // 基类部分被默认初始化而不是拷贝，成员初始值但没有提供基类初始值
    	{ ... }
}
```

**派生类赋值运算符：**也必须显示的使用基类部分赋值

```c++
base::operator=(const base&) // 不会自动调用

D &D:;operator=(const D &rhs)
{
	base::operator=(rhs);  //为基类部分赋值
    return *this;
}
// 基类的运算符可以正确的处理字赋值情况
// 基类运算符将释放掉左侧运算对象的基类部分的旧值，利用rhs为其赋个新值
// 再继续其他派生类成员的赋值
// 无论基类的构造函数和赋值运算符是自定义版本还是合成的版本，派生类的对应操作都和它们无关
```

**派生类的析构函数**：

1. 析构函数体执行完后，对象的成员会被隐式销毁
2. 对象的基类部分也是隐式销毁的
3. 派生类析构函数只负责销毁由派生类自己分配的资源

```c++
class D : public base {
public:
    ~D() { ... } // base::~base()被自动调用执行
}
//  对象的销毁顺序和创建顺序相反，派生类析构函数先执行，然后是基类的析构函数
```

在构造函数和析构函数中调用虚函数：   								**？**

1. 当执行基类的析构函数时，派生类部分已经被销毁了，执行基类成员时，该对象处于未完成状态
2. 当构建一个对象时，需要把对象的类和构造函数的类看作是同一个
3. **如果构造函数或析构函数调用了某个虚函数，我们应该执行与构造函数或析构函数所属类型对应的虚函数版本**

15.7.4 继承的构造函数

1. 派生类能**重用**其直接基类定义的构造函数
2. 一个类只能初始化它的直接基类，同样，一个类只能继承其直接基类的构造函数
3. 类不能继承默认、拷贝、移动构造函数，如果派生类没有直接定义这些函数，编译器会为类合成它们
4. 派生类继承基类的构造函数的方式是提供一条注明了基类名的using语句

```c++
class bulk_quote : public quote {
public:
    using quote::quote;  // 继承quote的构造函数
    double net_price(std::size_t) const;
}
// 当using作用于构造函数时，编译器在派生类中生成一个形参列表完全相同的构造函数
// 则等价于：
bulk_quote(const std::string& book, double price, 
          std::size_t qty, double disc) :
	quote(book, price, qty, disc) { }
// 如果派生类有自己的数据成员，这些成员将被默认初始化
```

继承的构造函数的特定：

1. 一个构造函数的using声明**不会改变该构造的函数的访问级别**，如私有的构造函数在派生类中还是私有的
2. 一个using 声明不能指定explicit和constexpr，如果基类的构造函数是explicit和constexpr的，继承的构造函数有相同的属性
3. 基类的构造函数含有默认实参时，这些实参不会被继承，而且派生类将获得多个继承的构造函数，**每个构造函数分别省略掉一个有默认实参的形参**
4. 如果基类有几个构造函数，派生类会继承所有这些构造函数，有两个例外
5. 第一个例外：派生类可以继承一部分构造函数，其他的通过定义相同的参数列表的自己的构造函数，替换继承来的
6. 第二个例外：默认、拷贝、移动构造函数不会被继承，这些构造函数按正常规则合成
7. 继承的构造函数不会被作为用户定义的构造函数使用，因此，**如果一个类只含有继承的构造函数，则它将拥有一个合成的默认构造函数**

15.8 容器与继承

